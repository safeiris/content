# Детерминированный конвейер генерации

Новый пайплайн состоит из четырёх атомарных шагов. Каждый шаг завершается сохранением чекпоинта, и в случае неудачи можно повторно запустить пайплайн с последнего успешного этапа. При повторном запуске никакие уже достигнутые условия (длина, ключи, FAQ) не нарушаются.

## Шаг A. Скелет
* Формируется каркас статьи с разделами `Введение → Основная часть → FAQ → Вывод`.
* В блок FAQ вставляется плейсхолдер `<!--FAQ_START--> … <!--FAQ_END-->`.
* Длина черновика ограничена 3–3.5 тысячами символов без пробелов, чтобы обеспечить запас для последующих шагов.
* В метаданных фиксируется чекпоинт `skeleton` с длиной текста.

## Шаг B. Ключи
* Каждая целевая ключевая фраза вставляется в естественный контекст.
* Вокруг точных вхождений размещаются теги защиты: `<!--LOCK_START term="…">` и `<!--LOCK_END-->`.
* Если не удаётся органично встроить отдельные ключи, автоматически добавляется врезка «### Разбираемся в терминах» с краткими пояснениями.
* Шаг завершается только при 100% покрытии списка ключей. В противном случае пайплайн останавливается на этом этапе.

## Шаг C. FAQ и JSON-LD
* На основе унифицированного набора Q/A создаётся Markdown-блок FAQ ровно с пятью парами «Вопрос/Ответ».
* Параллельно формируется JSON-LD разметка `FAQPage`, синхронизированная с Markdown-версией.
* Оба артефакта записываются за один проход. Плейсхолдер FAQ заменяется готовым списком, JSON-LD добавляется в конец статьи.
* Чекпоинт `faq` фиксирует содержимое блока и перечень вопросов.

## Шаг D. Приоритетный триммер
* Рассчитывается резерв под JSON-LD и только затем запускается мягкое сокращение статьи.
* Триммер удаляет второстепенные абзацы, не затрагивая защищённые LOCK-фрагменты и блок FAQ.
* После сокращения повторно проверяются длина, ключевые фразы и FAQ. Если хотя бы один критерий не соблюдён, шаг повторяется.

## Валидация
* Финальный валидатор проверяет:
  * длину 3500–6000 знаков без пробелов;
  * наличие всех ключей (по LOCK-тегам);
  * строго пять вопросов в FAQ;
  * корректный JSON-LD `FAQPage`.
* Результат записывается в метаданные (`validation.passed` и `validation.stats`). При любом «красном» статусе артефакты не фиксируются.

## Управление артефактами
* Все файлы пишутся атомарно: `*.tmp → rename`.
* После успешной валидации обновляются `artifacts/index.json`, `latest.json` и `changelog.json` (с отметкой времени и исполнителя).
* `latest.json` хранит ссылку на актуальную версию статьи, `changelog.json` — историю публикаций.

## Повторный запуск
* Для UI предусмотрен сценарий «Повторить», который стартует с первого проваленного шага: например, после сбоя на шаге C будет выполнен только FAQ+JSON-LD, без пересборки скелета и ключей.
