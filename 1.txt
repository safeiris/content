diff --git a/config.py b/config.py
index a22afeb1bce629d09fffe24790d51a8bb6f69710..60fbc6ee530b854813d951b1cffe4427c891ac74 100644
--- a/config.py
+++ b/config.py
@@ -85,25 +85,29 @@ TAIL_FILL_MAX_TOKENS = max(200, _env_int("TAIL_FILL_MAX_TOKENS", 700))
 # Дефолтные настройки ядра
 DEFAULT_TONE = "экспертный, дружелюбный"
 DEFAULT_STRUCTURE = ["Введение", "Основная часть", "FAQ", "Вывод"]
 
 # Простая «норма» для SEO: ориентир по упоминаниям ключей на ~100 слов
 DEFAULT_SEO_DENSITY = 2
 
 # Рекомендуемые границы объёма (знаков)
 DEFAULT_MIN_LENGTH = 5200
 DEFAULT_MAX_LENGTH = 6800
 
 # Максимальный объём пользовательского контекста (символов)
 MAX_CUSTOM_CONTEXT_CHARS = 20_000
 
 # Стилевые профили
 STYLE_PROFILE_PATH = "profiles/finance/style_profile.md"
 STYLE_PROFILE_VARIANT = str(os.getenv("STYLE_PROFILE_VARIANT", "full")).strip().lower() or "full"
 if STYLE_PROFILE_VARIANT not in {"full", "light"}:
     STYLE_PROFILE_VARIANT = "full"
 APPEND_STYLE_PROFILE_DEFAULT = (
     str(os.getenv("APPEND_STYLE_PROFILE_DEFAULT", "true")).strip().lower() not in {"0", "false", "off", "no"}
 )
 
 # Ключевые слова
 KEYWORDS_ALLOW_AUTO = _env_bool("KEYWORDS_ALLOW_AUTO", False)
+
+# Feature flags controlling visibility of advanced UI controls
+FEATURE_HIDE_MODEL_SELECTOR = _env_bool("FEATURE_HIDE_MODEL_SELECTOR", True)
+FEATURE_HIDE_TOKEN_SLIDERS = _env_bool("FEATURE_HIDE_TOKEN_SLIDERS", True)
diff --git a/frontend_demo/index.html b/frontend_demo/index.html
index 3e80751d716a255b74e961be3dedc0b7fad9b77c..2484d5a9c610348a62e137b5270e1883806c339b 100644
--- a/frontend_demo/index.html
+++ b/frontend_demo/index.html
@@ -156,52 +156,68 @@
               <h3>Предпросмотр промпта</h3>
               <div class="prompt-grid">
                 <article>
                   <header>SYSTEM</header>
                   <pre id="preview-system" class="prompt-text">Нажмите «Сгенерировать», чтобы увидеть контент.</pre>
                 </article>
                 <article>
                   <header>
                     CONTEXT <span id="context-badge" class="badge neutral">не запрошен</span>
                   </header>
                   <ul id="context-list" class="context-list"></ul>
                   <p id="context-summary" class="context-summary"></p>
                 </article>
                 <article>
                   <header>USER</header>
                   <pre id="preview-user" class="prompt-text"></pre>
                 </article>
               </div>
             </section>
             <article id="draft-view" class="draft-view"></article>
           </div>
           <aside class="result-aside">
             <h3>Отчет о качестве</h3>
             <div id="report-view" class="report-view"></div>
             <div class="download-buttons">
-              <button id="download-md" class="secondary" disabled>Скачать .md</button>
-              <button id="download-report" class="secondary" disabled>Скачать отчёт .json</button>
+              <a
+                id="download-md"
+                class="secondary"
+                role="button"
+                aria-disabled="true"
+                data-fallback-name="draft.md"
+              >
+                <span class="btn-label">Скачать .md</span>
+              </a>
+              <a
+                id="download-report"
+                class="secondary"
+                role="button"
+                aria-disabled="true"
+                data-fallback-name="report.json"
+              >
+                <span class="btn-label">Скачать отчёт .json</span>
+              </a>
             </div>
           </aside>
         </div>
       </section>
     </main>
 
     <div id="progress-overlay" class="progress-overlay hidden" role="alert" aria-live="polite">
       <div class="progress-card">
         <div class="spinner"></div>
         <p data-role="progress-message">Генерируем материалы…</p>
       </div>
     </div>
 
     <template id="source-row-template">
       <div class="source-row">
         <textarea class="source-input" rows="2" placeholder="https://example.com"></textarea>
         <button type="button" class="icon-button remove-source" aria-label="Удалить источник">✕</button>
       </div>
     </template>
 
     <template id="artifact-card-template">
       <article class="card">
         <div class="card-header">
           <h3 class="card-title"></h3>
           <span class="status"></span>
diff --git a/frontend_demo/script.js b/frontend_demo/script.js
index a30f0b78825aa7fb526ad93c17d63f307b90f33f..be69d338d7148f62ef752d07639cdb0f9eb0efc1 100644
--- a/frontend_demo/script.js
+++ b/frontend_demo/script.js
@@ -138,132 +138,164 @@ const HEALTH_STATUS_MESSAGES = {
     ok: "найден",
     fail: "не найден",
   },
   artifacts_writable: {
     label: "Каталог артефактов",
     ok: "доступен",
     fail: "недоступен",
   },
   theme_index: {
     label: "Индекс темы",
     ok: "найден",
     fail: "не найден",
   },
 };
 
 const STYLE_PROFILE_HINTS = {
   "sravni.ru": "Экспертный, структурный стиль: введение → основная часть → FAQ → вывод.",
   "tinkoff.ru": "Дружелюбный и прагматичный тон: объясняем шаги на примерах и даём советы.",
   "banki.ru": "Аналитичный стиль: выделяем выгоды и риски, формулируем выводы по фактам.",
   off: "Нейтральный деловой стиль без привязки к порталу.",
 };
 
 const state = {
   pipes: new Map(),
   artifacts: [],
+  artifactFiles: [],
+  pendingArtifactFiles: null,
   hasMissingArtifacts: false,
   currentResult: null,
+  currentDownloads: { markdown: null, report: null },
+};
+
+const featureState = {
+  hideModelSelector: true,
+  hideTokenSliders: true,
 };
 
 const customContextState = {
   textareaText: "",
   fileText: "",
   fileName: "",
   noticeShown: false,
 };
 
+function resolveApiPath(path) {
+  if (typeof path !== "string" || !path) {
+    return API_BASE || "";
+  }
+  if (/^https?:\/\//i.test(path)) {
+    return path;
+  }
+  const base = API_BASE || "";
+  const normalizedBase = base.endsWith("/") ? base.slice(0, -1) : base;
+  const normalizedPath = path.startsWith("/") ? path : `/${path}`;
+  if (/^https?:\/\//i.test(normalizedBase)) {
+    return `${normalizedBase}${normalizedPath}`;
+  }
+  return `${normalizedBase}${normalizedPath}`;
+}
+
 function escapeHtml(value) {
   if (typeof value !== "string") {
     return "";
   }
   const map = {
     "&": "&amp;",
     "<": "&lt;",
     ">": "&gt;",
     '"': "&quot;",
     "'": "&#39;",
   };
   return value.replace(/[&<>"']/g, (char) => map[char] || char);
 }
 
 const devActionsConfig = resolveDevActions();
 if (!devActionsConfig.show && advancedSupportSection) {
   advancedSupportSection.remove();
   reindexBtn = null;
   healthBtn = null;
 }
 
+initFeatureFlags();
+
 const interactiveElements = [generateBtn];
 
 if (reindexBtn) {
   interactiveElements.push(reindexBtn);
 }
 if (healthBtn) {
   interactiveElements.push(healthBtn);
 }
 if (cleanupArtifactsBtn) {
   interactiveElements.push(cleanupArtifactsBtn);
 }
 
 tabs.forEach((tab) => {
   tab.addEventListener("click", () => switchTab(tab.dataset.tab));
 });
 
 if (structurePreset) {
   structurePreset.addEventListener("change", () => applyStructurePreset(structurePreset.value));
 }
 pipeSelect.addEventListener("change", () => applyPipeDefaults(pipeSelect.value));
 briefForm.addEventListener("submit", handleGenerate);
 if (retryBtn) {
   retryBtn.addEventListener("click", handleRetryClick);
 }
 if (styleProfileSelect) {
   styleProfileSelect.addEventListener("change", handleStyleProfileChange);
 }
 if (contextSourceSelect) {
   contextSourceSelect.addEventListener("change", handleContextSourceChange);
 }
 if (customContextTextarea) {
   customContextTextarea.addEventListener("input", handleCustomContextInput);
 }
 if (customContextFileInput) {
   customContextFileInput.addEventListener("change", handleCustomContextFileChange);
 }
 if (customContextClearBtn) {
   customContextClearBtn.addEventListener("click", handleCustomContextClear);
 }
 if (reindexBtn) {
   reindexBtn.addEventListener("click", handleReindex);
 }
 if (healthBtn) {
   healthBtn.addEventListener("click", handleHealthCheck);
 }
 if (cleanupArtifactsBtn) {
   cleanupArtifactsBtn.addEventListener("click", handleArtifactsCleanup);
 }
-downloadMdBtn.addEventListener("click", () => handleDownload("markdown"));
-downloadReportBtn.addEventListener("click", () => handleDownload("metadata"));
+if (downloadMdBtn) {
+  setDownloadLinkAvailability(downloadMdBtn, null);
+  downloadMdBtn.addEventListener("click", (event) => handleDownloadClick(event, "markdown"));
+}
+if (downloadReportBtn) {
+  setDownloadLinkAvailability(downloadReportBtn, null);
+  downloadReportBtn.addEventListener("click", (event) => handleDownloadClick(event, "report"));
+}
 if (clearLogBtn) {
   clearLogBtn.addEventListener("click", () => {
     clearReindexLog();
     showToast({ message: "Журнал очищен", type: "info" });
   });
 }
 
 setupAdvancedSettings();
 handleStyleProfileChange();
 handleFaqToggle();
 handleContextSourceChange();
 updateCustomContextCounter();
 init();
 
 function switchTab(tabId) {
   tabs.forEach((tab) => tab.classList.toggle("active", tab.dataset.tab === tabId));
   panels.forEach((panel) => panel.classList.toggle("active", panel.id === tabId));
 }
 
 function handleStyleProfileChange() {
   if (!styleProfileSelect || !styleProfileHint) {
     return;
   }
   const value = styleProfileSelect.value || "off";
   styleProfileHint.textContent = STYLE_PROFILE_HINTS[value] || STYLE_PROFILE_HINTS.off;
@@ -617,233 +649,576 @@ function renderPipeCards(pipes) {
     card.className = "pipe-card";
     const header = document.createElement("div");
     const title = document.createElement("h3");
     title.textContent = pipe.name;
     const description = document.createElement("p");
     description.textContent = pipe.description || `Тематика ${pipe.name}`;
     header.append(title, description);
 
     const meta = document.createElement("div");
     meta.className = "pipe-meta";
     meta.innerHTML = `Тон: <strong>${pipe.tone || "—"}</strong>`;
 
     const keywordsWrapper = document.createElement("div");
     keywordsWrapper.className = "pipe-keywords";
     (pipe.keywords || []).slice(0, 8).forEach((keyword) => {
       const badge = document.createElement("span");
       badge.textContent = keyword;
       keywordsWrapper.append(badge);
     });
 
     card.append(header, meta, keywordsWrapper);
     pipesList.append(card);
   });
 }
 
-async function loadArtifacts() {
-  let artifacts;
-  try {
-    artifacts = await fetchJson("/api/artifacts");
-  } catch (error) {
-    artifactsList.innerHTML = '<div class="empty-state">Не удалось загрузить материалы.</div>';
-    state.artifacts = [];
-    state.hasMissingArtifacts = false;
-    updateArtifactsToolbar();
-    throw error;
+async function fetchArtifactFiles() {
+  const artifacts = await fetchJson("/api/artifacts");
+  if (Array.isArray(artifacts)) {
+    return artifacts;
   }
-  const items = Array.isArray(artifacts)
-    ? artifacts
-    : artifacts && Array.isArray(artifacts.items)
-      ? artifacts.items
-      : null;
-  if (!items) {
+  if (artifacts && Array.isArray(artifacts.items)) {
+    return artifacts.items;
+  }
+  throw new Error("Некорректный ответ сервера");
+}
+
+async function loadArtifacts(prefetched = null) {
+  let files = prefetched;
+  if (!Array.isArray(files)) {
+    try {
+      files = await fetchArtifactFiles();
+    } catch (error) {
+      artifactsList.innerHTML = '<div class="empty-state">Не удалось загрузить материалы.</div>';
+      state.artifacts = [];
+      state.artifactFiles = [];
+      state.hasMissingArtifacts = false;
+      updateArtifactsToolbar();
+      throw error;
+    }
+  }
+  if (!Array.isArray(files)) {
     artifactsList.innerHTML = '<div class="empty-state">Некорректный ответ сервера.</div>';
     state.artifacts = [];
+    state.artifactFiles = [];
     state.hasMissingArtifacts = false;
     updateArtifactsToolbar();
     throw new Error("Некорректный ответ сервера");
   }
-  state.artifacts = normalizeArtifactList(items);
+  state.artifactFiles = files;
+  state.artifacts = normalizeArtifactList(files);
   state.hasMissingArtifacts = state.artifacts.some((artifact) => artifact.missing);
   renderArtifacts();
   updateArtifactsToolbar();
 }
 
 function renderArtifacts() {
   state.hasMissingArtifacts = state.artifacts.some((item) => item.missing);
   if (!state.artifacts.length) {
     artifactsList.innerHTML = '<div class="empty-state">Пока нет сгенерированных материалов.</div>';
     updateArtifactsToolbar();
     return;
   }
 
   artifactsList.innerHTML = "";
   const template = document.getElementById("artifact-card-template");
 
   state.artifacts.forEach((artifact) => {
     const card = template.content.firstElementChild.cloneNode(true);
     const metadata = artifact.metadata || {};
     const title = artifact.name || metadata.name || artifact.id || "Без названия";
     const themeName = metadata.theme || extractThemeFromName(title);
     const topic = metadata.input_data?.theme || metadata.data?.theme || metadata.topic || "Без темы";
     card.dataset.artifactId = artifact.id || artifact.path || "";
     card.querySelector(".card-title").textContent = title;
     const statusInfo = resolveArtifactStatus(artifact);
     const statusEl = card.querySelector(".status");
     statusEl.textContent = statusInfo.label;
     statusEl.dataset.status = statusInfo.value;
     const topicText = [themeName, topic].filter(Boolean).join(" · ") || topic;
     card.querySelector(".card-topic").textContent = topicText;
     const updatedAt = artifact.modified_at ? new Date(artifact.modified_at) : null;
     card.querySelector(".card-meta").textContent = updatedAt
       ? `Обновлено ${updatedAt.toLocaleString("ru-RU")}`
       : "Дата обновления неизвестна";
 
     card.addEventListener("click", () => showArtifact(artifact));
 
     const openBtn = card.querySelector(".open-btn");
     const downloadBtn = card.querySelector(".download-btn");
     const deleteBtn = card.querySelector(".delete-btn");
+    const hasMarkdown = Boolean(artifact.downloads?.markdown);
     if (openBtn) {
-      openBtn.disabled = !artifact.path;
+      openBtn.disabled = !hasMarkdown;
       openBtn.addEventListener("click", (event) => {
         event.stopPropagation();
         showArtifact(artifact);
       });
     }
     if (downloadBtn) {
-      downloadBtn.disabled = !artifact.path;
+      downloadBtn.disabled = !hasMarkdown;
       downloadBtn.addEventListener("click", async (event) => {
         event.stopPropagation();
         await handleArtifactDownload(artifact);
       });
     }
     if (deleteBtn) {
       deleteBtn.addEventListener("click", async (event) => {
         event.stopPropagation();
         await handleDeleteArtifact(artifact, deleteBtn);
       });
     }
 
     artifactsList.append(card);
   });
   updateArtifactsToolbar();
 }
 
 function resolveArtifactStatus(artifact) {
   const rawStatus = artifact?.status || artifact?.metadata?.status;
   if (!rawStatus) {
     return { value: "Ready", label: "Готов" };
   }
   const normalized = String(rawStatus).trim().toLowerCase();
   if (!normalized) {
     return { value: "Ready", label: "Готов" };
   }
   if (["ready", "ok", "success", "final"].includes(normalized)) {
     return { value: "Ready", label: "Готов" };
   }
   if (["draft", "dry-run", "dry_run"].includes(normalized)) {
     return { value: "Draft", label: "Черновик" };
   }
   if (["error", "failed"].includes(normalized)) {
     return { value: "Error", label: "Ошибка" };
   }
   return { value: rawStatus, label: rawStatus };
 }
 
 function normalizeArtifactList(items) {
-  return items.map((item) => {
-    const metadata = item && typeof item.metadata === "object" && !Array.isArray(item.metadata) ? item.metadata : {};
+  const groups = new Map();
+
+  items.forEach((item) => {
+    if (!item || typeof item !== "object") {
+      return;
+    }
+    const metadata = item.metadata && typeof item.metadata === "object" && !Array.isArray(item.metadata)
+      ? item.metadata
+      : {};
     const fallbackId =
-      typeof crypto !== "undefined" && crypto.randomUUID
-        ? crypto.randomUUID()
-        : `artifact-${Date.now()}-${Math.random().toString(16).slice(2)}`;
-    const id = typeof item.id === "string" && item.id.trim()
-      ? item.id.trim()
-      : typeof item.path === "string" && item.path.trim()
-        ? item.path.trim()
-        : metadata.id || metadata.artifact_id || fallbackId;
-    const path = typeof item.path === "string" && item.path.trim() ? item.path.trim() : null;
-    const metadataPath = typeof item.metadata_path === "string" && item.metadata_path.trim()
-      ? item.metadata_path.trim()
-      : null;
-    const name = typeof item.name === "string" && item.name.trim()
-      ? item.name.trim()
-      : typeof metadata.name === "string" && metadata.name.trim()
-        ? metadata.name.trim()
-        : id;
+      typeof item.artifact_id === "string" && item.artifact_id.trim()
+        ? item.artifact_id.trim()
+        : typeof item.id === "string" && item.id.trim()
+          ? item.id.trim()
+          : typeof item.path === "string" && item.path.trim()
+            ? item.path.trim()
+            : metadata.id || metadata.artifact_id || null;
+    const groupId = fallbackId || (typeof item.name === "string" ? item.name.replace(/\.[^.]+$/, "").trim() : null);
+    if (!groupId) {
+      return;
+    }
+    if (!groups.has(groupId)) {
+      groups.set(groupId, {
+        id: groupId,
+        name: null,
+        metadata: {},
+        status: null,
+        path: null,
+        metadata_path: null,
+        downloads: { markdown: null, report: null },
+        modified_at: null,
+        modified_ts: null,
+        size: null,
+        job_id: null,
+      });
+    }
+    const group = groups.get(groupId);
+    if (!group) {
+      return;
+    }
+
+    const downloadInfo = createDownloadInfoFromFile(item);
+    const type = (item.type || "").toString().toLowerCase();
+    const isMarkdown = type === "md" || (typeof item.name === "string" && item.name.toLowerCase().endsWith?.(".md"));
+    const isJson = type === "json" || (typeof item.name === "string" && item.name.toLowerCase().endsWith?.(".json"));
+
+    if (isMarkdown && downloadInfo) {
+      group.downloads.markdown = downloadInfo;
+      group.path = downloadInfo.path || item.artifact_path || downloadInfo.url || group.path;
+      if (!group.name) {
+        group.name = typeof item.name === "string" && item.name.trim()
+          ? item.name.trim()
+          : metadata.title || metadata.name || null;
+      }
+    }
+    if (isJson && downloadInfo) {
+      group.downloads.report = downloadInfo;
+      group.metadata_path = downloadInfo.path || item.metadata_path || downloadInfo.url || group.metadata_path;
+    }
+
+    if (Object.keys(metadata).length) {
+      group.metadata = metadata;
+      if (!group.name) {
+        const metaName = metadata.input_data?.theme || metadata.theme || metadata.name;
+        if (metaName) {
+          group.name = metaName;
+        }
+      }
+      if (!group.status && typeof metadata.status === "string") {
+        group.status = metadata.status;
+      }
+      if (!group.job_id && typeof metadata.job_id === "string") {
+        group.job_id = metadata.job_id;
+      }
+    }
+
+    if (!group.status && typeof item.status === "string") {
+      group.status = item.status;
+    }
+    if (!group.job_id && typeof item.job_id === "string") {
+      group.job_id = item.job_id;
+    }
+    if (typeof item.size === "number") {
+      group.size = item.size;
+    }
+
+    const createdAt = typeof item.created_at === "string" && item.created_at.trim()
+      ? item.created_at.trim()
+      : downloadInfo?.created_at || null;
+    const createdTs = parseTimestamp(createdAt);
+    if (createdTs !== null && (group.modified_ts === null || createdTs > group.modified_ts)) {
+      group.modified_ts = createdTs;
+      group.modified_at = createdAt;
+    }
+  });
+
+  return Array.from(groups.values()).map((group) => {
+    const name = group.name || group.metadata?.name || group.metadata?.input_data?.theme || group.id;
     return {
-      id,
+      id: group.id,
       name,
-      path,
-      metadata_path: metadataPath,
-      metadata,
-      size: typeof item.size === "number" ? item.size : null,
-      modified_at: item.modified_at || null,
-      status: item.status || metadata.status || null,
-      missing: Boolean(item.missing),
+      path: group.path,
+      metadata_path: group.metadata_path,
+      metadata: group.metadata || {},
+      size: typeof group.size === "number" ? group.size : null,
+      modified_at: group.modified_at,
+      status: group.status || null,
+      job_id: group.job_id || null,
+      downloads: group.downloads,
+      missing: !group.downloads.markdown,
     };
   });
 }
 
+function parseTimestamp(value) {
+  if (typeof value !== "string" || !value.trim()) {
+    return null;
+  }
+  const direct = Date.parse(value);
+  if (!Number.isNaN(direct)) {
+    return direct;
+  }
+  const normalized = Date.parse(value.replace(/\s+/, "T"));
+  return Number.isNaN(normalized) ? null : normalized;
+}
+
+function createDownloadInfoFromFile(item) {
+  if (!item || typeof item !== "object") {
+    return null;
+  }
+  const url = typeof item.url === "string" && item.url.trim() ? item.url.trim() : null;
+  const path = typeof item.path === "string" && item.path.trim() ? item.path.trim() : null;
+  const name = typeof item.name === "string" && item.name.trim() ? item.name.trim() : null;
+  const size = typeof item.size === "number" ? item.size : null;
+  const createdAt = typeof item.created_at === "string" && item.created_at.trim() ? item.created_at.trim() : null;
+  if (!url && !path) {
+    return null;
+  }
+  const info = {
+    url,
+    path,
+    name,
+    size,
+    created_at: createdAt,
+    job_id: item.job_id || null,
+  };
+  if (!info.url && info.path) {
+    info.url = `/api/artifacts/download?path=${encodeURIComponent(info.path)}`;
+  }
+  return info;
+}
+
+function setDownloadLinkAvailability(link, downloadInfo) {
+  if (!link) {
+    return;
+  }
+  const fallbackName = link.dataset.fallbackName || (link.id === "download-md" ? "draft.md" : "report.json");
+  if (downloadInfo && (downloadInfo.url || downloadInfo.path)) {
+    const targetUrl = downloadInfo.url || `/api/artifacts/download?path=${encodeURIComponent(downloadInfo.path)}`;
+    const resolvedUrl = resolveApiPath(targetUrl);
+    link.href = resolvedUrl;
+    link.dataset.downloadUrl = resolvedUrl;
+    link.setAttribute("download", downloadInfo.name || fallbackName);
+    link.classList.remove("is-disabled");
+    link.removeAttribute("aria-disabled");
+    return;
+  }
+  link.removeAttribute("href");
+  link.removeAttribute("download");
+  link.classList.add("is-disabled");
+  link.setAttribute("aria-disabled", "true");
+  delete link.dataset.downloadUrl;
+}
+
+function setActiveArtifactDownloads(downloads) {
+  const normalized = downloads && typeof downloads === "object" ? downloads : {};
+  state.currentDownloads = {
+    markdown: normalized.markdown || normalized.article || null,
+    report: normalized.report || normalized.json || normalized.metadata || null,
+  };
+  setDownloadLinkAvailability(downloadMdBtn, state.currentDownloads.markdown);
+  setDownloadLinkAvailability(downloadReportBtn, state.currentDownloads.report);
+}
+
+function resetDownloadButtonsForNewJob() {
+  state.currentDownloads = { markdown: null, report: null };
+  setDownloadLinkAvailability(downloadMdBtn, null);
+  setDownloadLinkAvailability(downloadReportBtn, null);
+  setButtonLoading(downloadMdBtn, true);
+  setButtonLoading(downloadReportBtn, true);
+}
+
+function handleDownloadClick(event, type) {
+  const link = type === "markdown" ? downloadMdBtn : downloadReportBtn;
+  if (!link) {
+    return;
+  }
+  if (link.classList.contains("loading") || link.getAttribute("aria-disabled") === "true") {
+    event.preventDefault();
+    if (!link.classList.contains("loading")) {
+      showToast({ message: "Файл недоступен для скачивания", type: "warn" });
+    }
+    return;
+  }
+  const downloadInfo = type === "markdown" ? state.currentDownloads.markdown : state.currentDownloads.report;
+  if (!downloadInfo) {
+    event.preventDefault();
+    showToast({ message: "Файл недоступен для скачивания", type: "warn" });
+    return;
+  }
+  event.preventDefault();
+  const fallbackName = link.dataset.fallbackName || (type === "markdown" ? "draft.md" : "report.json");
+  downloadArtifactFile(downloadInfo, fallbackName);
+}
+
+function extractArtifactPathHints(artifactPaths) {
+  const hints = new Set();
+  if (!artifactPaths || typeof artifactPaths !== "object") {
+    return hints;
+  }
+  ["markdown", "metadata", "json"].forEach((key) => {
+    const raw = artifactPaths[key];
+    if (typeof raw === "string" && raw.trim()) {
+      const name = raw.split("/").pop() || raw;
+      hints.add(name.replace(/\.[^.]+$/, ""));
+    }
+  });
+  return hints;
+}
+
+function findLatestArtifactPair(files, { jobId = null, artifactPaths = null } = {}) {
+  if (!Array.isArray(files) || !files.length) {
+    return null;
+  }
+
+  const groups = new Map();
+  const hints = extractArtifactPathHints(artifactPaths);
+
+  const isMarkdownFile = (file) => {
+    const type = (file?.type || "").toString().toLowerCase();
+    if (type === "md") {
+      return true;
+    }
+    const name = typeof file?.name === "string" ? file.name.toLowerCase() : "";
+    return name.endsWith(".md");
+  };
+
+  const isJsonFile = (file) => {
+    const type = (file?.type || "").toString().toLowerCase();
+    if (type === "json") {
+      return true;
+    }
+    const name = typeof file?.name === "string" ? file.name.toLowerCase() : "";
+    return name.endsWith(".json");
+  };
+
+  files.forEach((file) => {
+    if (!file || typeof file !== "object") {
+      return;
+    }
+    const artifactId = typeof file.artifact_id === "string" && file.artifact_id.trim()
+      ? file.artifact_id.trim()
+      : null;
+    const name = typeof file.name === "string" ? file.name : "";
+    const baseName = name ? name.replace(/\.[^.]+$/, "") : null;
+    const key = artifactId || baseName;
+    if (!key) {
+      return;
+    }
+    if (!groups.has(key)) {
+      groups.set(key, {
+        files: [],
+        jobIds: new Set(),
+        createdTs: null,
+        baseName: baseName || key,
+      });
+    }
+    const group = groups.get(key);
+    if (!group) {
+      return;
+    }
+    group.files.push(file);
+    if (file.job_id) {
+      group.jobIds.add(file.job_id);
+    }
+    const createdTs = parseTimestamp(typeof file.created_at === "string" ? file.created_at : null);
+    if (createdTs !== null && (group.createdTs === null || createdTs > group.createdTs)) {
+      group.createdTs = createdTs;
+    }
+  });
+
+  const availableGroups = Array.from(groups.entries()).filter(([_, group]) => group.files.some(isMarkdownFile));
+  if (!availableGroups.length) {
+    return null;
+  }
+
+  const selectByJob = jobId
+    ? availableGroups.find(([_, group]) => group.jobIds.has(jobId))
+    : null;
+  if (selectByJob) {
+    const group = selectByJob[1];
+    const markdown = group.files.find(isMarkdownFile) || null;
+    const report = group.files.find(isJsonFile) || null;
+    return { markdown, report };
+  }
+
+  const selectByHint = hints.size
+    ? availableGroups.find(([key, group]) => hints.has(group.baseName) || hints.has(key))
+    : null;
+  if (selectByHint) {
+    const group = selectByHint[1];
+    const markdown = group.files.find(isMarkdownFile) || null;
+    const report = group.files.find(isJsonFile) || null;
+    return { markdown, report };
+  }
+
+  availableGroups.sort((a, b) => (b[1].createdTs || 0) - (a[1].createdTs || 0));
+  const latest = availableGroups[0]?.[1];
+  if (!latest) {
+    return null;
+  }
+  const markdown = latest.files.find(isMarkdownFile) || null;
+  const report = latest.files.find(isJsonFile) || null;
+  return { markdown, report };
+}
+
+function hasDraftStepSucceeded(snapshot) {
+  if (!snapshot || !Array.isArray(snapshot.steps)) {
+    return false;
+  }
+  return snapshot.steps.some((step) => step && step.name === "draft" && step.status === "succeeded");
+}
+
+async function refreshDownloadLinksForJob({ jobId = null, artifactPaths = null } = {}) {
+  if (!downloadMdBtn || !downloadReportBtn) {
+    return null;
+  }
+  try {
+    const files = await fetchArtifactFiles();
+    state.pendingArtifactFiles = files;
+    const pair = findLatestArtifactPair(files, { jobId, artifactPaths });
+    const downloads = pair
+      ? {
+          markdown: pair.markdown ? createDownloadInfoFromFile(pair.markdown) : null,
+          report: pair.report ? createDownloadInfoFromFile(pair.report) : null,
+        }
+      : { markdown: null, report: null };
+    setButtonLoading(downloadMdBtn, false);
+    setButtonLoading(downloadReportBtn, false);
+    setActiveArtifactDownloads(downloads);
+    if (state.currentResult && typeof state.currentResult === "object") {
+      state.currentResult.downloads = downloads;
+    }
+    return downloads;
+  } catch (error) {
+    console.warn("Не удалось обновить ссылки на артефакты", error);
+    setButtonLoading(downloadMdBtn, false);
+    setButtonLoading(downloadReportBtn, false);
+    setActiveArtifactDownloads({ markdown: null, report: null });
+    return null;
+  }
+}
+
 function resolveArtifactIdentifier(artifact) {
   if (!artifact) {
     return null;
   }
   if (typeof artifact === "string") {
     return artifact;
   }
   if (typeof artifact.id === "string" && artifact.id.trim()) {
     return artifact.id.trim();
   }
   if (typeof artifact.path === "string" && artifact.path.trim()) {
     return artifact.path.trim();
   }
   return null;
 }
 
 function removeArtifactFromState(artifact) {
   const identifier = resolveArtifactIdentifier(artifact);
   if (!identifier) {
     return false;
   }
   const before = state.artifacts.length;
   state.artifacts = state.artifacts.filter((item) => resolveArtifactIdentifier(item) !== identifier);
   const changed = state.artifacts.length !== before;
   state.hasMissingArtifacts = state.artifacts.some((item) => item.missing);
   if (changed) {
     renderArtifacts();
   }
   return changed;
 }
 
 async function handleArtifactDownload(artifact) {
-  if (!artifact?.path) {
+  const downloadInfo = artifact?.downloads?.markdown || null;
+  if (!downloadInfo) {
     showToast({ message: "Файл недоступен для скачивания", type: "warn" });
     return false;
   }
-  const result = await downloadArtifactFile(artifact.path, artifact.name || "artifact.txt", artifact);
+  const fallbackName = artifact?.name || downloadInfo.name || "artifact.txt";
+  const result = await downloadArtifactFile(downloadInfo, fallbackName, artifact);
   return result === "ok";
 }
 
 async function handleDeleteArtifact(artifact, button) {
   const title = artifact?.name || artifact?.id || "этот результат";
   const confirmed = window.confirm(`Удалить результат «${title}»?`);
   if (!confirmed) {
     return;
   }
   try {
     setButtonLoading(button, true);
     const payload = {};
     if (artifact.id) {
       payload.id = artifact.id;
     }
     if (artifact.path) {
       payload.path = artifact.path;
     }
     const response = await fetchJson("/api/artifacts", {
       method: "DELETE",
       body: JSON.stringify(payload),
     });
     const removed = removeArtifactFromState(artifact);
     if (!removed) {
       try {
@@ -1032,115 +1407,154 @@ async function handlePromptPreview() {
       previewRequest.context_text = payload.context_text;
       if (payload.context_filename) {
         previewRequest.context_filename = payload.context_filename;
       }
     }
     const preview = await fetchJson("/api/prompt/preview", {
       method: "POST",
       body: JSON.stringify(previewRequest),
     });
     updatePromptPreview(preview);
     switchTab("result");
   } catch (error) {
     console.error(error);
     showToast({ message: `Не удалось собрать промпт: ${getErrorMessage(error)}`, type: "error" });
   } finally {
     setButtonLoading(previewBtn, false);
     setInteractiveBusy(false);
     showProgress(false);
   }
 }
 
 async function handleGenerate(event) {
   event.preventDefault();
   try {
     const payload = buildRequestPayload();
+    resetDownloadButtonsForNewJob();
+    state.pendingArtifactFiles = null;
+    let downloadsRequested = false;
+    let activeJobId = null;
+    let artifactPathsHint = null;
     toggleRetryButton(false);
     setInteractiveBusy(true);
     setButtonLoading(generateBtn, true);
     showProgress(true, DEFAULT_PROGRESS_MESSAGE);
     renderUsedKeywords(null);
     const requestBody = {
       theme: payload.theme,
       data: payload.data,
       k: payload.k,
       context_source: payload.context_source,
     };
     if (Array.isArray(payload.data?.keywords)) {
       requestBody.keywords = payload.data.keywords;
     }
     requestBody.length_range = {
       min: DEFAULT_LENGTH_RANGE.min,
       max: DEFAULT_LENGTH_RANGE.max,
       mode: "no_spaces",
     };
     requestBody.faq_required = true;
     requestBody.faq_count = 5;
     if (payload.context_source === "custom") {
       requestBody.context_text = payload.context_text;
       if (payload.context_filename) {
         requestBody.context_filename = payload.context_filename;
       }
     }
     const initialResponse = await fetchJson("/api/generate", {
       method: "POST",
       body: JSON.stringify(requestBody),
     });
     let snapshot = normalizeJobResponse(initialResponse);
+    activeJobId = snapshot.job_id || snapshot.id || activeJobId;
+    if (snapshot.result && typeof snapshot.result === "object" && snapshot.result.artifact_paths) {
+      artifactPathsHint = snapshot.result.artifact_paths;
+    }
     const initialChars = applyProgressiveResult(snapshot) || 0;
     showProgress(true, describeJobProgress(snapshot, initialChars));
+    if (!downloadsRequested && hasDraftStepSucceeded(snapshot)) {
+      downloadsRequested = true;
+      refreshDownloadLinksForJob({ jobId: activeJobId, artifactPaths: artifactPathsHint }).catch((error) => {
+        console.warn("Не удалось заранее получить ссылки на артефакты", error);
+      });
+    }
     if (snapshot.status !== "succeeded" || !snapshot.result) {
       if (!snapshot.job_id) {
         throw new Error("Сервер вернул пустой ответ без идентификатора задания.");
       }
       snapshot = await pollJobUntilDone(snapshot.job_id, {
         onUpdate: (update) => {
           const liveChars = applyProgressiveResult(update) || 0;
           if (update?.status === "succeeded" || update?.status === "failed") {
             showProgress(false);
           } else {
             showProgress(true, describeJobProgress(update, liveChars));
           }
+          if (!downloadsRequested && hasDraftStepSucceeded(update)) {
+            downloadsRequested = true;
+            activeJobId = update?.id || update?.job_id || activeJobId;
+            if (update?.result && typeof update.result === "object" && update.result.artifact_paths) {
+              artifactPathsHint = update.result.artifact_paths;
+            }
+            refreshDownloadLinksForJob({ jobId: activeJobId, artifactPaths: artifactPathsHint }).catch((error) => {
+              console.warn("Не удалось заранее получить ссылки на артефакты", error);
+            });
+          }
         },
       });
     }
+    activeJobId = snapshot?.id || snapshot?.job_id || activeJobId;
+    if (snapshot?.result && typeof snapshot.result === "object" && snapshot.result.artifact_paths) {
+      artifactPathsHint = snapshot.result.artifact_paths;
+    }
+    if (!downloadsRequested && hasDraftStepSucceeded(snapshot)) {
+      downloadsRequested = true;
+      await refreshDownloadLinksForJob({ jobId: activeJobId, artifactPaths: artifactPathsHint });
+    }
     renderGenerationResult(snapshot, { payload });
     try {
-      await loadArtifacts();
+      const pendingFiles = state.pendingArtifactFiles;
+      await loadArtifacts(pendingFiles);
     } catch (refreshError) {
       console.error(refreshError);
       showToast({ message: `Не удалось обновить список материалов: ${getErrorMessage(refreshError)}`, type: "warn" });
     }
+    state.pendingArtifactFiles = null;
     switchTab("result");
     showToast({ message: "Готово", type: "success" });
   } catch (error) {
     console.error(error);
     showToast({ message: `Не удалось выполнить генерацию: ${getErrorMessage(error)}`, type: "error" });
+    setButtonLoading(downloadMdBtn, false);
+    setButtonLoading(downloadReportBtn, false);
+    setActiveArtifactDownloads(null);
   } finally {
     setButtonLoading(generateBtn, false);
     setInteractiveBusy(false);
     showProgress(false);
+    state.pendingArtifactFiles = null;
   }
 }
 
 function normalizeJobResponse(response) {
   if (!response || typeof response !== "object") {
     return { status: "pending", result: null, steps: [], degradation_flags: [], job_id: null };
   }
   if (typeof response.markdown === "string" || typeof response.meta_json === "object") {
     return {
       status: "succeeded",
       job_id: response.job_id || null,
       steps: Array.isArray(response.steps) ? response.steps : [],
       degradation_flags: Array.isArray(response.degradation_flags) ? response.degradation_flags : [],
       trace_id: response.trace_id || null,
       message: typeof response.message === "string" ? response.message : null,
       progress: typeof response.progress === "number" ? response.progress : null,
       step: typeof response.step === "string" ? response.step : null,
       last_event_at: response.last_event_at || null,
       result: {
         markdown: typeof response.markdown === "string" ? response.markdown : "",
         meta_json: (response.meta_json && typeof response.meta_json === "object") ? response.meta_json : {},
         faq_entries: Array.isArray(response.faq_entries) ? response.faq_entries : [],
       },
     };
   }
@@ -1293,84 +1707,92 @@ async function watchJobViaPolling(jobId, { onUpdate } = {}) {
       }
       throw error;
     }
     if (snapshot?.status === "succeeded" && snapshot.result) {
       return snapshot;
     }
     delayMs = Math.min(delayMs + 200, 1500);
   }
 }
 
 function renderGenerationResult(snapshot, { payload }) {
   const normalized = normalizeJobResponse(snapshot);
   const result = normalized.result || {};
   const markdown = typeof result.markdown === "string" ? result.markdown : "";
   const meta = (result.meta_json && typeof result.meta_json === "object") ? result.meta_json : {};
   const degradationFlags = Array.isArray(normalized.degradation_flags) ? normalized.degradation_flags : [];
   const characters = typeof meta.characters === "number" ? meta.characters : markdown.replace(/\s+/g, "").length;
   const hasContent = markdown.trim().length > 0;
   state.currentResult = {
     markdown,
     meta,
     artifactPaths: result.artifact_paths ?? null,
     characters,
     hasContent,
     degradationFlags,
+    downloads:
+      state.currentDownloads && (state.currentDownloads.markdown || state.currentDownloads.report)
+        ? { ...state.currentDownloads }
+        : null,
   };
   draftView.innerHTML = markdownToHtml(markdown);
   resultTitle.textContent = payload?.data?.theme || "Результат генерации";
   const metaParts = [];
   if (hasContent) {
     metaParts.push(`Символов: ${characters.toLocaleString("ru-RU")}`);
     metaParts.push(
       `Ориентир: ${DEFAULT_LENGTH_RANGE.min.toLocaleString("ru-RU")}` +
         `–${DEFAULT_LENGTH_RANGE.max.toLocaleString("ru-RU")}` +
         ` (≤ ${DEFAULT_LENGTH_RANGE.hard.toLocaleString("ru-RU")})`,
     );
   }
   if (degradationFlags.length) {
     metaParts.push(`Деградации: ${degradationFlags.length}`);
   }
   if (meta.model_used) {
     metaParts.push(`Модель: ${meta.model_used}`);
   }
   resultMeta.textContent = metaParts.join(" · ") || "Деградаций нет";
   renderMetadata(meta);
   renderUsedKeywords(meta);
   updateResultBadges(meta, degradationFlags);
   toggleRetryButton(!hasContent);
   updatePromptPreview({
     system: meta.system_prompt_preview,
     context: Array.isArray(meta.clips) ? meta.clips : [],
     user: meta.user_prompt_preview,
     context_used: meta.context_used,
     context_index_missing: meta.context_index_missing,
     context_budget_tokens_est: meta.context_budget_tokens_est,
     context_budget_tokens_limit: meta.context_budget_tokens_limit,
     k: payload?.k,
   });
-  enableDownloadButtons(result.artifact_paths ?? null);
+  if (state.currentResult.downloads) {
+    setButtonLoading(downloadMdBtn, false);
+    setButtonLoading(downloadReportBtn, false);
+    setActiveArtifactDownloads(state.currentResult.downloads);
+  }
   if (degradationFlags.length) {
     const label = degradationFlags.map(describeDegradationFlag).join(", ");
     showToast({ message: `Частичная деградация: ${label}`, type: "warn", duration: 6000 });
   }
 }
 
 function describeDegradationFlag(flag) {
   if (!flag) {
     return "unknown";
   }
   return DEGRADATION_LABELS[flag] || flag;
 }
 
 const delay = (ms) => new Promise((resolve) => {
   setTimeout(resolve, ms);
 });
 
 function handleRetryClick(event) {
   event.preventDefault();
   if (briefForm && typeof briefForm.requestSubmit === "function") {
     briefForm.requestSubmit(generateBtn);
     return;
   }
   if (generateBtn) {
     generateBtn.click();
@@ -1949,132 +2371,113 @@ function updatePromptPreview(preview) {
   }
 
   if (isCustom) {
     const lengthValue = Number(preview.context_len || 0);
     contextSummary.textContent = lengthValue
       ? `Пользовательский контекст: ${lengthValue.toLocaleString("ru-RU")} символов`
       : "";
   } else if (typeof preview.context_budget_tokens_est === "number") {
     const limit = preview.context_budget_tokens_limit;
     contextSummary.textContent = limit
       ? `Контекст: ~${preview.context_budget_tokens_est} токенов из лимита ${limit}`
       : `Контекст: ~${preview.context_budget_tokens_est} токенов`;
   } else {
     contextSummary.textContent = "";
   }
 }
 
 function toggleRetryButton(show) {
   if (!retryBtn) {
     return;
   }
   retryBtn.hidden = !show;
   retryBtn.disabled = !show;
 }
 
-function enableDownloadButtons(paths) {
-  const normalizePath = (value) =>
-    typeof value === "string" && value.trim().length > 0 ? value.trim() : null;
-
-  const markdownPath = normalizePath(paths?.markdown);
-  const metadataPath = normalizePath(paths?.metadata);
-
-  if (markdownPath) {
-    downloadMdBtn.dataset.path = markdownPath;
-    downloadMdBtn.disabled = false;
-  } else {
-    downloadMdBtn.disabled = true;
-    delete downloadMdBtn.dataset.path;
-  }
-
-  if (metadataPath) {
-    downloadReportBtn.dataset.path = metadataPath;
-    downloadReportBtn.disabled = false;
-  } else {
-    downloadReportBtn.disabled = true;
-    delete downloadReportBtn.dataset.path;
-  }
-}
-
-async function handleDownload(type) {
-  const button = type === "markdown" ? downloadMdBtn : downloadReportBtn;
-  const path = button.dataset.path;
-  if (!path) {
-    showToast({ message: "Файл недоступен для скачивания", type: "warn" });
-    return;
-  }
-  const result = await downloadArtifactFile(
-    path,
-    type === "markdown" ? "draft.md" : "report.json"
-  );
-  if (result === "not_found") {
-    button.disabled = true;
-    delete button.dataset.path;
-  }
-}
-
 async function showArtifact(artifact) {
   try {
     showProgress(true, "Загружаем артефакт…");
-    const markdownPath = artifact.path;
-    if (!markdownPath) {
+    const markdownDownload = artifact?.downloads?.markdown || null;
+    const markdownUrl = markdownDownload?.url
+      || (artifact.path ? `/api/artifacts/download?path=${encodeURIComponent(artifact.path)}` : null);
+    if (!markdownUrl) {
       handleMissingArtifact(artifact);
       return;
     }
-    const markdown = await fetchText(`/api/artifacts/download?path=${encodeURIComponent(markdownPath)}`);
+    const markdown = await fetchText(markdownUrl);
     const metadataPath = artifact.metadata_path;
+    const metadataDownload = artifact?.downloads?.report || null;
     let metadata = artifact.metadata || {};
-    if (!Object.keys(metadata).length && metadataPath) {
+    if (!Object.keys(metadata).length && (metadataDownload?.url || metadataPath)) {
       try {
-        const jsonText = await fetchText(`/api/artifacts/download?path=${encodeURIComponent(metadataPath)}`);
+        const metadataUrl = metadataDownload?.url
+          || (metadataPath ? `/api/artifacts/download?path=${encodeURIComponent(metadataPath)}` : null);
+        const jsonText = metadataUrl ? await fetchText(metadataUrl) : "";
         metadata = JSON.parse(jsonText);
       } catch (parseError) {
         console.warn("Не удалось разобрать метаданные", parseError);
         metadata = {};
       }
     }
     draftView.innerHTML = markdownToHtml(markdown);
     resultTitle.textContent = metadata.input_data?.theme || metadata.theme || artifact.name;
     const characters = metadata.characters ?? markdown.length;
     resultMeta.textContent = `Символов: ${characters.toLocaleString("ru-RU")} · Модель: ${metadata.model_used ?? "—"}`;
     renderMetadata(metadata);
     updateResultBadges(metadata, Array.isArray(metadata?.degradation_flags) ? metadata.degradation_flags : []);
-    enableDownloadButtons({ markdown: artifact.path, metadata: metadataPath });
+    setButtonLoading(downloadMdBtn, false);
+    setButtonLoading(downloadReportBtn, false);
+    setActiveArtifactDownloads(artifact.downloads || {
+      markdown: markdownDownload,
+      report: metadataDownload,
+    });
     updatePromptPreview({
       system: metadata.system_prompt_preview,
       context: metadata.clips || [],
       user: metadata.user_prompt_preview,
       context_used: metadata.context_used,
       context_index_missing: metadata.context_index_missing,
       context_budget_tokens_est: metadata.context_budget_tokens_est,
       context_budget_tokens_limit: metadata.context_budget_tokens_limit,
       k: metadata.retrieval_k,
       context_source: metadata.context_source,
       context_text: metadata.custom_context_text,
       context_len: metadata.context_len,
       context_filename: metadata.context_filename,
     });
+    state.currentResult = {
+      markdown,
+      meta: metadata,
+      artifactPaths: { markdown: artifact.path || null, metadata: metadataPath || null },
+      characters,
+      hasContent: true,
+      degradationFlags: Array.isArray(metadata?.degradation_flags) ? metadata.degradation_flags : [],
+      downloads: artifact.downloads || {
+        markdown: markdownDownload,
+        report: metadataDownload,
+      },
+    };
     switchTab("result");
   } catch (error) {
     console.error(error);
     if (isNotFoundError(error)) {
       handleMissingArtifact(artifact);
       return;
     }
     showToast({ message: `Не удалось открыть артефакт: ${getErrorMessage(error)}`, type: "error" });
   } finally {
     showProgress(false);
   }
 }
 
 async function handleReindex(event) {
   if (event) {
     event.preventDefault();
   }
   const theme = pipeSelect.value;
   if (!theme) {
     showToast({ message: "Выберите тематику для переиндексации", type: "warn" });
     return;
   }
 
   appendLogEntry("info", `Запрос на переиндексацию темы «${theme}»`);
   try {
@@ -2261,101 +2664,103 @@ function createHealthCard({ tone, icon, label, description = "", delay = 0 }) {
 }
 
 function setGenerateAvailability(ok, reason = "") {
   if (!generateBtn) {
     return;
   }
   if (ok) {
     generateBtn.disabled = false;
     generateBtn.removeAttribute("title");
   } else {
     generateBtn.disabled = true;
     if (reason) {
       generateBtn.title = reason;
     } else {
       generateBtn.removeAttribute("title");
     }
   }
 }
 
 async function fetchJson(path, options = {}) {
   const headers = options.headers ? { ...options.headers } : {};
   if (options.method && options.method !== "GET") {
     headers["Content-Type"] = "application/json";
   }
 
+  const url = resolveApiPath(path);
   let response;
   try {
-    response = await fetch(`${API_BASE}${path}`, { ...options, headers });
+    response = await fetch(url, { ...options, headers });
   } catch (error) {
     throw new Error("Сервер недоступен");
   }
 
   let text;
   try {
     text = await response.text();
   } catch (error) {
     throw new Error("Не удалось прочитать ответ сервера");
   }
 
   if (!response.ok) {
     let message = text || `HTTP ${response.status}`;
     if (text) {
       try {
         const data = JSON.parse(text);
         if (data && typeof data.error === "string" && data.error.trim()) {
           message = data.error.trim();
         } else if (data && data.error && typeof data.error.message === "string" && data.error.message.trim()) {
           message = data.error.message.trim();
         }
       } catch (parseError) {
         if (!(parseError instanceof Error) || parseError.name !== "SyntaxError") {
           parseError.status = response.status;
           throw parseError;
         }
       }
     }
     const error = new Error(message || `HTTP ${response.status}`);
     error.status = response.status;
     throw error;
   }
 
   if (!text.trim()) {
     return {};
   }
 
   try {
     return JSON.parse(text);
   } catch (error) {
     throw new Error("Некорректный JSON в ответе сервера");
   }
 }
 
 async function fetchText(path) {
+  const url = resolveApiPath(path);
   let response;
   try {
-    response = await fetch(`${API_BASE}${path}`);
+    response = await fetch(url);
   } catch (error) {
     throw new Error("Сервер недоступен");
   }
   const text = await response.text();
   if (!response.ok) {
     const error = new Error(text || `HTTP ${response.status}`);
     error.status = response.status;
     throw error;
   }
   return text;
 }
 
 function setupAdvancedSettings() {
   if (!advancedSettings) {
     return;
   }
 
   if (advancedSupportSection && devActionsConfig.show && devActionsConfig.hasExplicit) {
     const title = advancedSupportSection.querySelector(".advanced-section-title");
     if (title) {
       title.textContent = "Техподдержка";
     }
     const caption = advancedSupportSection.querySelector(".advanced-section-caption");
     if (caption) {
       caption.remove();
@@ -2433,135 +2838,233 @@ function setButtonLoading(button, isLoading) {
   if (isLoading) {
     if (!button.dataset.originalDisabled) {
       button.dataset.originalDisabled = button.disabled ? "true" : "false";
     }
     button.disabled = true;
     button.classList.add("loading");
     if (!button.querySelector(".btn-spinner")) {
       const spinner = document.createElement("span");
       spinner.className = "btn-spinner";
       button.prepend(spinner);
     }
   } else {
     const spinner = button.querySelector(".btn-spinner");
     if (spinner) {
       spinner.remove();
     }
     button.classList.remove("loading");
     const shouldRemainDisabled = button.dataset.originalDisabled === "true";
     if (!shouldRemainDisabled) {
       button.disabled = false;
     }
     delete button.dataset.originalDisabled;
   }
 }
 
+function toggleFeatureElements(elements, hidden) {
+  elements
+    .filter(Boolean)
+    .forEach((element) => {
+      const target = element.closest?.("[data-feature-root]")
+        || element.closest?.(".form-row")
+        || element;
+      if (!target) {
+        return;
+      }
+      if (hidden) {
+        target.classList.add("feature-hidden");
+      } else {
+        target.classList.remove("feature-hidden");
+      }
+    });
+}
+
+function applyFeatureFlags() {
+  const modelElements = [];
+  if (modelInput) {
+    modelElements.push(modelInput);
+  }
+  document.querySelectorAll('[data-feature="model-selector"]').forEach((element) => {
+    modelElements.push(element);
+  });
+  toggleFeatureElements(modelElements, featureState.hideModelSelector);
+
+  const tokenElements = [];
+  if (maxTokensInput) {
+    tokenElements.push(maxTokensInput);
+  }
+  if (minCharsInput) {
+    tokenElements.push(minCharsInput);
+  }
+  if (maxCharsInput) {
+    tokenElements.push(maxCharsInput);
+  }
+  if (kInput) {
+    tokenElements.push(kInput);
+  }
+  document.querySelectorAll('[data-feature="token-sliders"]').forEach((element) => {
+    tokenElements.push(element);
+  });
+  toggleFeatureElements(tokenElements, featureState.hideTokenSliders);
+}
+
+async function initFeatureFlags() {
+  applyFeatureFlags();
+  try {
+    const config = await fetchJson("/api/features");
+    if (config && typeof config === "object") {
+      if (typeof config.hide_model_selector === "boolean") {
+        featureState.hideModelSelector = config.hide_model_selector;
+      }
+      if (typeof config.hide_token_sliders === "boolean") {
+        featureState.hideTokenSliders = config.hide_token_sliders;
+      }
+    }
+  } catch (error) {
+    console.debug("Не удалось загрузить настройки фич", error);
+  } finally {
+    applyFeatureFlags();
+  }
+}
+
 function resolveDevActions() {
   let rawValue;
   if (typeof globalThis !== "undefined" && typeof globalThis.SHOW_DEV_ACTIONS !== "undefined") {
     rawValue = globalThis.SHOW_DEV_ACTIONS;
   } else if (typeof document !== "undefined" && document.body?.dataset?.showDevActions) {
     rawValue = document.body.dataset.showDevActions;
   }
 
   const hasExplicit = typeof rawValue !== "undefined" && rawValue !== null;
   let show = true;
 
   if (hasExplicit) {
     if (typeof rawValue === "string") {
       const normalized = rawValue.trim().toLowerCase();
       show = normalized === "true" || normalized === "1";
     } else if (typeof rawValue === "boolean") {
       show = rawValue;
     } else {
       show = Boolean(rawValue);
     }
   }
 
   return { show, hasExplicit };
 }
 
 function getErrorMessage(error, fallback = "Неизвестная ошибка") {
   if (!error) {
     return fallback;
   }
   if (typeof error === "string") {
     return error;
   }
   if (typeof error.message === "string" && error.message.trim()) {
     return error.message;
   }
   return fallback;
 }
 
 function isNotFoundError(error) {
   return Boolean(error && typeof error.status === "number" && error.status === 404);
 }
 
-async function downloadArtifactFile(path, fallbackName = "artifact.txt", artifact = null) {
-  if (!path) {
+async function downloadArtifactFile(resource, fallbackName = "artifact.txt", artifact = null) {
+  const normalized = (() => {
+    if (!resource) {
+      return null;
+    }
+    if (typeof resource === "string") {
+      const trimmed = resource.trim();
+      if (!trimmed) {
+        return null;
+      }
+      return {
+        url: resolveApiPath(`/api/artifacts/download?path=${encodeURIComponent(trimmed)}`),
+        name: fallbackName,
+      };
+    }
+    if (typeof resource === "object") {
+      const candidateUrl = typeof resource.url === "string" && resource.url.trim() ? resource.url.trim() : null;
+      const candidatePath = typeof resource.path === "string" && resource.path.trim() ? resource.path.trim() : null;
+      const name = typeof resource.name === "string" && resource.name.trim() ? resource.name.trim() : fallbackName;
+      if (candidateUrl) {
+        return { url: resolveApiPath(candidateUrl), name };
+      }
+      if (candidatePath) {
+        return {
+          url: resolveApiPath(`/api/artifacts/download?path=${encodeURIComponent(candidatePath)}`),
+          name,
+        };
+      }
+    }
+    return null;
+  })();
+
+  if (!normalized) {
     showToast({ message: "Файл недоступен", type: "warn" });
     return "error";
   }
+
   try {
-    const response = await fetch(`${API_BASE}/api/artifacts/download?path=${encodeURIComponent(path)}`);
+    const response = await fetch(normalized.url);
     if (!response.ok) {
       let message = `HTTP ${response.status}`;
       let notFound = false;
       let raw = "";
       try {
         raw = await response.text();
       } catch (readError) {
         raw = "";
       }
       if (raw) {
         message = raw;
         try {
           const data = JSON.parse(raw);
           if (data && typeof data.error === "string") {
             message = data.error;
             if (response.status === 404 && data.error === "file_not_found") {
               notFound = true;
               message = "Файл не найден";
             }
           }
         } catch (parseError) {
           // ignore JSON parse failures
         }
       }
       const error = new Error(message || `HTTP ${response.status}`);
       error.status = response.status;
       if (notFound) {
         error.code = "file_not_found";
       }
       throw error;
     }
     const blob = await response.blob();
     const url = URL.createObjectURL(blob);
     const anchor = document.createElement("a");
     anchor.href = url;
-    anchor.download = path.split("/").pop() || fallbackName;
+    anchor.download = normalized.name || fallbackName;
     document.body.append(anchor);
     anchor.click();
     anchor.remove();
     URL.revokeObjectURL(url);
     return "ok";
   } catch (error) {
     console.error(error);
     if (isNotFoundError(error)) {
       const message = error.code === "file_not_found" ? "Файл не найден" : getErrorMessage(error);
       showToast({ message, type: "warn" });
       if (artifact) {
         handleMissingArtifact(artifact);
       }
       return error.code === "file_not_found" ? "not_found" : "error";
     }
     showToast({ message: `Не удалось скачать файл: ${getErrorMessage(error)}`, type: "error" });
     return "error";
   }
 }
 
 function appendLogEntry(status, message) {
   if (!reindexLog) {
     return;
   }
   const tone = LOG_STATUS_LABELS[status] ? status : "info";
diff --git a/frontend_demo/styles.css b/frontend_demo/styles.css
index b4124a18f79d44a3a47c3a2bef5ae934616522f8..b13a696b02cdb349ccc68d515ac0c9ced0540018 100644
--- a/frontend_demo/styles.css
+++ b/frontend_demo/styles.css
@@ -1,42 +1,46 @@
 :root {
   font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
   color: #1d1d1f;
   background-color: #ffffff;
   --app-max-width: 1440px;
   --section-gap: 24px;
 }
 
 body {
   margin: 0;
   min-height: 100vh;
   display: flex;
   flex-direction: column;
   background-color: #f7f8fa;
   overflow-x: hidden;
 }
 
+.feature-hidden {
+  display: none !important;
+}
+
 .app-shell {
   width: min(100%, var(--app-max-width));
   margin: 0 auto;
   padding: 0 24px;
   box-sizing: border-box;
   overflow-x: hidden;
 }
 
 @media (max-width: 959px) {
   .app-shell {
     padding: 0 16px;
   }
 }
 
 .app-header {
   background-color: #ffffff;
   border-bottom: 1px solid #e4e7ec;
   padding: 24px 0;
 }
 
 .header-inner {
   display: flex;
   align-items: center;
   justify-content: space-between;
 }
@@ -652,87 +656,104 @@ button {
   font-weight: 600;
 }
 
 .primary {
   background-color: #4f46e5;
   color: #ffffff;
   border: none;
   border-radius: 12px;
   padding: 12px 20px;
   font-size: 16px;
   cursor: pointer;
   transition: background-color 0.2s ease, transform 0.2s ease;
 }
 
 .primary:hover {
   background-color: #4338ca;
   transform: translateY(-1px);
 }
 
 .secondary {
   background: #ffffff;
   color: #1d1d1f;
   border: 1px solid #d4d8dd;
   border-radius: 10px;
   padding: 10px 18px;
+  text-decoration: none;
   cursor: pointer;
   transition: border-color 0.2s ease;
 }
 
 .secondary.subtle {
   background: #f8fafc;
   border-color: #e2e8f0;
 }
 
 .secondary.subtle:hover {
   border-color: #cbd5f5;
 }
 
 .secondary.danger {
   background: #fef2f2;
   border-color: #fecaca;
   color: #b91c1c;
 }
 
 .secondary.danger:hover {
   border-color: #f87171;
   background: #fee2e2;
   color: #991b1b;
 }
 
 .secondary.danger:disabled {
   background: #fef2f2;
   border-color: #fecaca;
   color: #fca5a5;
 }
 
 .secondary:disabled {
   cursor: not-allowed;
   color: #9ca3af;
   border-color: #e5e7eb;
 }
 
+.secondary.is-disabled,
+.secondary[aria-disabled="true"] {
+  cursor: not-allowed;
+  color: #9ca3af;
+  border-color: #e5e7eb;
+  pointer-events: none;
+}
+
+.secondary.loading {
+  cursor: progress;
+}
+
+button.loading {
+  cursor: progress;
+}
+
 .ghost {
   background: transparent;
   color: #4b5563;
   border: 1px dashed #cbd5f5;
   border-radius: 10px;
   padding: 10px 18px;
   cursor: pointer;
   transition: color 0.2s ease, border-color 0.2s ease;
 }
 
 .ghost.small {
   padding: 6px 12px;
   font-size: 13px;
   border-radius: 8px;
 }
 
 .ghost.attention {
   color: #b91c1c;
   border-color: #f87171;
 }
 
 .ghost.attention:hover {
   color: #991b1b;
   border-color: #dc2626;
 }
@@ -1500,54 +1521,51 @@ button {
 
 @keyframes spin {
   to {
     transform: rotate(360deg);
   }
 }
 
 .empty-state {
   text-align: center;
   color: #9ca3af;
   padding: 40px;
   border: 1px dashed #e2e8f0;
   border-radius: 16px;
   background: #ffffff;
 }
 
 .btn-spinner {
   width: 16px;
   height: 16px;
   border-radius: 50%;
   border: 2px solid currentColor;
   border-top-color: transparent;
   animation: spin 0.9s linear infinite;
 }
 
-button.loading {
-  cursor: progress;
-}
-
+.secondary.loading .btn-label,
 button.loading .btn-label {
   opacity: 0.75;
 }
 
 .toast-root {
   position: fixed;
   inset-inline: 0;
   bottom: 24px;
   display: grid;
   justify-content: center;
   gap: 12px;
   pointer-events: none;
   padding: 0 24px;
   z-index: 120;
 }
 
 .toast {
   background: rgba(15, 23, 42, 0.92);
   color: #f8fafc;
   padding: 12px 16px;
   border-radius: 12px;
   box-shadow: 0 18px 40px rgba(15, 23, 42, 0.3);
   display: inline-flex;
   align-items: center;
   gap: 10px;
diff --git a/server/__init__.py b/server/__init__.py
index 29e3a74733bbd946a44858fa784d65cc9af57a0f..21cb03b0dcc6d0dfaaedd4820b066dab364af4dd 100644
--- a/server/__init__.py
+++ b/server/__init__.py
@@ -1,72 +1,75 @@
 """Flask application exposing the content factory pipeline via HTTP."""
 from __future__ import annotations
 
 import json
 import mimetypes
 import os
 import secrets
 import time
 import uuid
-from datetime import datetime
+from datetime import datetime, timezone
 from functools import wraps
 from pathlib import Path
 from typing import Any, Dict, List, Optional, Tuple
 from urllib.parse import urljoin, urlparse
 
 from dotenv import load_dotenv
 from flask import (
     Flask,
     Response,
     abort,
     flash,
     jsonify,
     g,
     redirect,
     render_template,
     request,
     session,
-    send_file,
     send_from_directory,
     stream_with_context,
     url_for,
 )
 from flask_cors import CORS
 from werkzeug.security import check_password_hash
+from werkzeug.utils import safe_join
 
 from assemble_messages import invalidate_style_profile_cache
 from config import (
     DEFAULT_STRUCTURE,
+    FEATURE_HIDE_MODEL_SELECTOR,
+    FEATURE_HIDE_TOKEN_SLIDERS,
     JOB_STORE_TTL_S,
     OPENAI_RPM,
     OPENAI_RPS,
 )
 from jobs import JobRunner, JobStatus, JobStore
 from orchestrate import gather_health_status, make_generation_context
 from llm_client import DEFAULT_MODEL
 from retrieval import build_index
 from artifacts_store import (
+    ARTIFACTS_DIR,
     cleanup_index as cleanup_artifact_index,
     delete_artifact as delete_artifact_entry,
     list_artifacts as list_artifact_cards,
     resolve_artifact_path,
 )
 from observability.logger import bind_trace_id, clear_trace_id, get_logger
 from observability.metrics import get_registry
 
 load_dotenv()
 
 LOGGER = get_logger("content_factory.api")
 
 PIPELINE_CONFIG_FILENAME = "pipeline.json"
 
 JOB_STORE = JobStore(ttl_seconds=JOB_STORE_TTL_S)
 JOB_RUNNER = JobRunner(JOB_STORE)
 
 USERS: Dict[str, Dict[str, str]] = {
     "admin": {
         "display_name": "Admin",
         "password_hash": (
             "scrypt:32768:8:1$poFMhgLX1D2jug2W$724005a9a37b1f699ddda576ee89fb022c3bdcd28660826d1f9f5710c3116c6"
             "b847ea20c926c9124fbcfa9fee55967a26d488e3d04a3b58e2776f002a124d003"
         ),
     },
@@ -489,105 +492,222 @@ def create_app() -> Flask:
                     break
                 time.sleep(1.0)
 
         response = Response(stream_with_context(_event_stream()), mimetype="text/event-stream")
         response.headers["Cache-Control"] = "no-cache"
         response.headers["X-Accel-Buffering"] = "no"
         return response
 
     @app.post("/api/reindex")
     def reindex():
         payload = _require_json(request)
         theme = str(payload.get("theme", "")).strip()
         if not theme:
             raise ApiError("Не указана тема (theme)")
 
         try:
             stats = build_index(theme)
         except FileNotFoundError as exc:
             raise ApiError(str(exc), status_code=404) from exc
         except RuntimeError as exc:
             raise ApiError(str(exc), status_code=400) from exc
 
         invalidate_style_profile_cache()
         return jsonify(stats)
 
+    def _normalize_iso8601(candidate: Optional[str], fallback_ts: Optional[float]) -> Optional[str]:
+        if isinstance(candidate, str) and candidate.strip():
+            value = candidate.strip()
+            try:
+                parsed = datetime.fromisoformat(value.replace("Z", "+00:00"))
+            except ValueError:
+                return value
+            return parsed.astimezone(timezone.utc).isoformat().replace("+00:00", "Z")
+        if fallback_ts is None:
+            return None
+        return (
+            datetime.fromtimestamp(fallback_ts, timezone.utc)
+            .isoformat()
+            .replace("+00:00", "Z")
+        )
+
+    def _send_artifact_file(relative_path: str):
+        safe_path = safe_join(str(ARTIFACTS_DIR), relative_path)
+        if safe_path is None:
+            raise ApiError("Недопустимый путь к артефакту", status_code=400)
+
+        file_path = Path(safe_path)
+        if not file_path.exists() or not file_path.is_file():
+            return jsonify({"error": "file_not_found"}), 404
+
+        try:
+            relative = file_path.relative_to(ARTIFACTS_DIR)
+        except ValueError as exc:
+            raise ApiError("Недопустимый путь к артефакту", status_code=400) from exc
+
+        suffix = file_path.suffix.lower()
+        if suffix == ".md":
+            mimetype = "text/markdown"
+        elif suffix == ".json":
+            mimetype = "application/json"
+        else:
+            guessed, _ = mimetypes.guess_type(file_path.name)
+            mimetype = guessed or "application/octet-stream"
+
+        return send_from_directory(
+            str(ARTIFACTS_DIR),
+            relative.as_posix(),
+            as_attachment=True,
+            download_name=file_path.name,
+            mimetype=mimetype,
+        )
+
     @app.get("/api/artifacts")
     def list_artifacts():
         theme = request.args.get("theme")
-        items = list_artifact_cards(theme, auto_cleanup=True)
-        return jsonify(items)
+        records = list_artifact_cards(theme, auto_cleanup=True)
+        files: List[Dict[str, Any]] = []
+
+        for record in records:
+            record_id = str(record.get("id") or "").strip() or None
+            metadata = record.get("metadata") or {}
+            if not isinstance(metadata, dict):
+                metadata = {}
+            status = record.get("status") or metadata.get("status") or "Ready"
+            job_id = metadata.get("job_id")
+
+            def _make_entry(path_value: Optional[str], file_type: str) -> Optional[Dict[str, Any]]:
+                if not path_value or not isinstance(path_value, str):
+                    return None
+                try:
+                    file_path = resolve_artifact_path(path_value)
+                except ValueError:
+                    return None
+                if not file_path.exists() or not file_path.is_file():
+                    return None
+                stat = file_path.stat()
+                try:
+                    relative = file_path.relative_to(ARTIFACTS_DIR).as_posix()
+                except ValueError:
+                    relative = file_path.name
+
+                created_at = _normalize_iso8601(
+                    metadata.get("generated_at") or record.get("modified_at"),
+                    stat.st_mtime,
+                )
+                entry: Dict[str, Any] = {
+                    "id": f"{record_id or file_path.stem}:{file_type}",
+                    "artifact_id": record_id or file_path.stem,
+                    "name": file_path.name,
+                    "type": file_type,
+                    "size": stat.st_size,
+                    "created_at": created_at,
+                    "url": url_for("download_artifact_file", filename=relative),
+                    "job_id": job_id,
+                    "path": relative,
+                    "status": status,
+                    "metadata": dict(metadata),
+                }
+                if file_type == "json":
+                    entry["metadata_path"] = relative
+                    entry["artifact_path"] = record.get("path")
+                else:
+                    entry["metadata_path"] = record.get("metadata_path")
+                    entry["artifact_path"] = relative
+                entry["_created_ts"] = stat.st_mtime
+                return entry
+
+            markdown_entry = _make_entry(record.get("path"), "md")
+            if markdown_entry:
+                files.append(markdown_entry)
+
+            metadata_entry = _make_entry(record.get("metadata_path"), "json")
+            if metadata_entry:
+                files.append(metadata_entry)
+
+        files.sort(key=lambda item: item.get("_created_ts") or 0, reverse=True)
+        for item in files:
+            item.pop("_created_ts", None)
+        return jsonify(files)
 
     @app.delete("/api/artifacts")
     def delete_artifact():
         payload = _require_json(request)
         identifier = str(payload.get("id") or payload.get("path") or "").strip()
         if not identifier:
             raise ApiError("Не указан идентификатор артефакта", status_code=400)
 
         result = delete_artifact_entry(identifier)
         status_code = 200
         if result.get("errors"):
             status_code = 207
 
         response_payload: Dict[str, Any] = {
             "deleted": bool(result.get("deleted")),
             "metadata_deleted": bool(result.get("metadata_deleted")),
             "not_found": bool(result.get("not_found")),
             "index_updated": bool(result.get("index_updated")),
             "removed_id": result.get("removed_id"),
             "removed_path": result.get("removed_path"),
         }
         if result.get("errors"):
             response_payload["errors"] = list(result["errors"])
         return jsonify(response_payload), status_code
 
     @app.post("/api/artifacts/cleanup")
     def cleanup_artifacts():
         result = cleanup_artifact_index()
         http_status = 200 if not result.get("errors") else 207
         return jsonify(result), http_status
 
     @app.get("/api/artifacts/download")
     def download_artifact():
         raw_path = request.args.get("path")
         if not raw_path:
             raise ApiError("Не указан путь к артефакту", status_code=400)
 
         try:
             artifact_path = resolve_artifact_path(raw_path)
         except ValueError as exc:
             raise ApiError(str(exc), status_code=400) from exc
-        if not artifact_path.exists() or not artifact_path.is_file():
-            return jsonify({"error": "file_not_found"}), 404
+        try:
+            relative = artifact_path.relative_to(ARTIFACTS_DIR).as_posix()
+        except ValueError as exc:
+            raise ApiError("Недопустимый путь к артефакту", status_code=400) from exc
+        return _send_artifact_file(relative)
 
-        mime_type, _ = mimetypes.guess_type(artifact_path.name)
-        return send_file(
-            artifact_path,
-            mimetype=mime_type or "application/octet-stream",
-            as_attachment=True,
-            download_name=artifact_path.name,
+    @app.get("/api/artifacts/<path:filename>")
+    def download_artifact_file(filename: str):
+        return _send_artifact_file(filename)
+
+    @app.get("/api/features")
+    def get_feature_flags():
+        return jsonify(
+            {
+                "hide_model_selector": FEATURE_HIDE_MODEL_SELECTOR,
+                "hide_token_sliders": FEATURE_HIDE_TOKEN_SLIDERS,
+            }
         )
 
     @app.get("/api/health")
     def health():
         theme = request.args.get("theme")
         status = gather_health_status(theme)
         checks = status.setdefault("checks", {})
         metrics_snapshot = get_registry().snapshot()
         queue_len = int(metrics_snapshot.get("jobs.queue_length", 0))
         checks["openai_rate_limits"] = {
             "ok": True,
             "message": f"Лимиты клиента активны: {OPENAI_RPS} rps / {OPENAI_RPM} rpm",
         }
         checks["job_runner"] = {
             "ok": True,
             "message": f"Очередь заданий: {len(JOB_STORE)}; soft timeout={JOB_RUNNER.soft_timeout()}s",
         }
         checks["job_queue"] = {
             "ok": queue_len < 10,
             "message": f"Размер очереди: {queue_len}",
         }
         if theme:
             profile_path = (Path("profiles") / theme / "style_profile.md").resolve()
             try:
                 mtime = profile_path.stat().st_mtime
diff --git a/tests/test_server_artifacts_api.py b/tests/test_server_artifacts_api.py
new file mode 100644
index 0000000000000000000000000000000000000000..e73bb69faba24a3848eef49b0a28822f1285db02
--- /dev/null
+++ b/tests/test_server_artifacts_api.py
@@ -0,0 +1,104 @@
+import json
+import sys
+from datetime import datetime, timezone
+from pathlib import Path
+
+import pytest
+
+PROJECT_ROOT = Path(__file__).resolve().parents[1]
+if str(PROJECT_ROOT) not in sys.path:
+    sys.path.insert(0, str(PROJECT_ROOT))
+
+from artifacts_store import register_artifact
+from server import create_app
+
+
+@pytest.fixture()
+def app(tmp_path, monkeypatch):
+    artifacts_dir = tmp_path / "artifacts"
+    artifacts_dir.mkdir()
+
+    monkeypatch.setattr("artifacts_store.ARTIFACTS_DIR", artifacts_dir)
+    monkeypatch.setattr("server.ARTIFACTS_DIR", artifacts_dir)
+
+    app = create_app()
+    app.config.update(TESTING=True, ARTIFACTS_DIR=str(artifacts_dir))
+    return app
+
+
+@pytest.fixture()
+def client(app):
+    return app.test_client()
+
+
+@pytest.fixture()
+def sample_artifacts(app):
+    artifacts_dir = Path(app.config["ARTIFACTS_DIR"])
+    markdown_path = artifacts_dir / "2025-01-02_1200_test.md"
+    markdown_path.parent.mkdir(parents=True, exist_ok=True)
+    markdown_path.write_text("# Заголовок\n\nСодержимое", encoding="utf-8")
+
+    metadata = {
+        "id": "artifact-001",
+        "name": "2025-01-02_1200_test.md",
+        "status": "succeeded",
+        "job_id": "job-xyz",
+        "generated_at": datetime(2025, 1, 2, 12, 1, tzinfo=timezone.utc).isoformat(),
+    }
+    metadata_path = markdown_path.with_suffix(".json")
+    metadata_path.write_text(json.dumps(metadata, ensure_ascii=False), encoding="utf-8")
+
+    register_artifact(markdown_path, metadata)
+
+    return {
+        "markdown_path": markdown_path,
+        "metadata_path": metadata_path,
+        "metadata": metadata,
+    }
+
+
+def test_list_artifacts_returns_file_entries(client, sample_artifacts):
+    response = client.get("/api/artifacts")
+    assert response.status_code == 200
+
+    payload = response.get_json()
+    assert isinstance(payload, list)
+    assert len(payload) == 2
+
+    markdown_entry = next(item for item in payload if item["type"] == "md")
+    json_entry = next(item for item in payload if item["type"] == "json")
+
+    assert markdown_entry["name"].endswith(".md")
+    assert markdown_entry["url"].startswith("/api/artifacts/")
+    assert markdown_entry["job_id"] == "job-xyz"
+    assert markdown_entry["status"] == "succeeded"
+    assert markdown_entry["created_at"].endswith("Z")
+
+    assert json_entry["name"].endswith(".json")
+    assert json_entry["url"].startswith("/api/artifacts/")
+    assert json_entry["metadata"]["job_id"] == "job-xyz"
+
+
+@pytest.mark.parametrize(
+    "extension,content_type",
+    [
+        (".md", "text/markdown"),
+        (".json", "application/json"),
+    ],
+)
+def test_download_artifact_serves_files_with_expected_mimetype(
+    client, sample_artifacts, extension, content_type
+):
+    response = client.get(f"/api/artifacts/2025-01-02_1200_test{extension}")
+    assert response.status_code == 200
+    assert content_type in response.headers["Content-Type"]
+    content_disposition = response.headers.get("Content-Disposition", "")
+    assert "attachment" in content_disposition
+    assert f"2025-01-02_1200_test{extension}" in content_disposition
+
+
+def test_download_artifact_unknown_path_returns_404(client):
+    response = client.get("/api/artifacts/not-found.md")
+    assert response.status_code == 404
+    data = response.get_json()
+    assert data == {"error": "file_not_found"}

