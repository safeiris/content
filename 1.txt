diff --git a/faq_builder.py b/faq_builder.py
index 9ee6da4705f704083d4fd7cc0f4bef2d5d24d0a4..797e022d12dd33650960082b301568030e9b9686 100644
--- a/faq_builder.py
+++ b/faq_builder.py
@@ -1,31 +1,34 @@
 from __future__ import annotations
 
 import json
 from dataclasses import dataclass
 from typing import Dict, Iterable, List, Sequence
 
+FAQ_MIN_COUNT = 6
+FAQ_MAX_COUNT = 8
+FAQ_DEFAULT_LIMIT = 7
 
 @dataclass
 class FaqEntry:
     question: str
     answer: str
     anchor: str
 
 
 @dataclass
 class FaqBuildResult:
     text: str
     entries: List[FaqEntry]
     jsonld: str
 
 
 def _sanitize_anchor(text: str) -> str:
     return "-" + "-".join(text.lower().split())
 
 
 def _normalize_answer(answer: str) -> str:
     paragraphs = [part.strip() for part in answer.split("\n\n") if part.strip()]
     if not paragraphs:
         raise ValueError("Ответ пустой")
     if len(paragraphs) > 3:
         paragraphs = paragraphs[:3]
@@ -33,73 +36,84 @@ def _normalize_answer(answer: str) -> str:
         raise ValueError("Ответ слишком короткий")
     return "\n\n".join(paragraphs)
 
 
 def _normalize_question(question: str, seen: set[str]) -> str:
     normalized = question.strip()
     if not normalized:
         raise ValueError("Вопрос пустой")
     if normalized.lower() in seen:
         raise ValueError("Дублирующийся вопрос")
     seen.add(normalized.lower())
     return normalized
 
 
 def _normalize_entry(raw: Dict[str, str], seen: set[str]) -> FaqEntry:
     question_raw = raw.get("question") if "question" in raw else raw.get("q")
     answer_raw = raw.get("answer") if "answer" in raw else raw.get("a")
     question = _normalize_question(str(question_raw or ""), seen)
     answer = _normalize_answer(str(answer_raw or ""))
     anchor = str(raw.get("anchor") or _sanitize_anchor(question))
     return FaqEntry(question=question, answer=answer, anchor=anchor)
 
 
 def _generate_generic_entries(topic: str, keywords: Sequence[str]) -> List[FaqEntry]:
     base_topic = topic or "теме"
-    key_iter = list(keywords)[:5]
+    key_iter = list(keywords)[:FAQ_MAX_COUNT]
     templates = [
         "Как оценить основные риски, связанные с {topic}?",
         "Какие шаги помогут подготовиться к решению вопросов по {topic}?",
         "Какие цифры считать ориентиром, когда речь заходит о {topic}?",
         "Как использовать программы поддержки, если речь идёт о {topic}?",
         "Что делать, если ситуация с {topic} резко меняется?",
+        "Как оптимизировать расходы, связанные с {topic}?",
+        "Какие ошибки чаще всего совершают при работе с {topic}?",
+        "Что контролировать после внедрения решений по {topic}?",
     ]
     answers = [
         "Начните с базовой диагностики: опишите текущую ситуацию, посчитайте ключевые показатели и зафиксируйте цели. "
         "Далее сопоставьте результаты с отраслевыми нормами и составьте план коррекции.",
-        "Сформируйте пошаговый чек-лист. Включите в него анализ документов, консультации с экспертами и список сервисов, которые помогут собрать данные. "
+        "Сформируйте пошаговый чек-лист. Включите в него анализ документов, консультации с экспертами и список сервисов, которые"
+        " помогают собрать данные. "
         "По мере продвижения фиксируйте выводы, чтобы вернуться к ним на этапе принятия решения.",
         "Используйте диапазон значений из методических материалов и банковской аналитики. "
         "Сравните собственные показатели с усреднёнными и определите пороги, при которых стоит пересмотреть стратегию.",
         "Изучите федеральные и региональные программы, подходящие под ваш профиль. "
         "Составьте список требований, подготовьте пакет документов и оцените сроки рассмотрения, чтобы не потерять время.",
-        "Создайте резервный план действий: определите, какие параметры контролировать ежемесячно, и заранее договоритесь о точках проверки. "
+        "Создайте резервный план действий: определите, какие параметры контролировать ежемесячно, и заранее договоритесь о точках"
+        " проверки. "
         "Если изменения превышают допустимый порог, инициируйте пересмотр стратегии и подключите независимую экспертизу.",
+        "Проверьте постоянные и переменные траты, сравните предложения подрядчиков и автоматизируйте рутинные операции, чтобы"
+        " снизить накладные расходы.",
+        "Отсутствие контроля за дедлайнами и финансовыми ограничениями, игнорирование обратной связи и слабая документация чаще"
+        " всего приводят к сбоям — заложите проверки на каждом этапе.",
+        "Отслеживайте показатели эффективности, фиксируйте обратную связь пользователей и заранее планируйте корректировки, чтобы"
+        " удерживать результат на нужном уровне.",
     ]
 
     entries: List[FaqEntry] = []
-    for idx in range(5):
+    for idx in range(FAQ_MAX_COUNT):
         keyword_hint = key_iter[idx] if idx < len(key_iter) else ""
         question = templates[idx].format(topic=base_topic)
         if keyword_hint:
             question = f"{question[:-1]} и {keyword_hint}?"
         answer = _normalize_answer(answers[idx])
         anchor = _sanitize_anchor(question)
         entries.append(FaqEntry(question=question, answer=answer, anchor=anchor))
     return entries
 
 
 def _render_markdown(entries: Sequence[FaqEntry]) -> str:
     lines: List[str] = []
     for idx, entry in enumerate(entries, start=1):
         lines.append(f"**Вопрос {idx}.** {entry.question}")
         lines.append(
             "**Ответ.** "
             + entry.answer
             + " Это помогает не только понять детали, но и оформить решение в рабочем формате."
         )
         lines.append("")
     return "\n".join(lines).strip()
 
 
 def _build_jsonld(entries: Sequence[FaqEntry]) -> str:
     payload = {
@@ -112,61 +126,70 @@ def _build_jsonld(entries: Sequence[FaqEntry]) -> str:
                 "acceptedAnswer": {"@type": "Answer", "text": entry.answer},
             }
             for entry in entries
         ],
     }
     compact = json.dumps(payload, ensure_ascii=False, separators=(",", ":"))
     return f'<script type="application/ld+json">\n{compact}\n</script>'
 
 
 def build_faq_block(
     *,
     base_text: str,
     topic: str,
     keywords: Iterable[str],
     provided_entries: Sequence[Dict[str, str]] | None = None,
 ) -> FaqBuildResult:
     entries: List[FaqEntry] = []
     seen_questions: set[str] = set()
     if provided_entries:
         for entry in provided_entries:
             try:
                 normalized = _normalize_entry(entry, seen_questions)
             except ValueError:
                 continue
             entries.append(normalized)
-            if len(entries) == 5:
+            if len(entries) == FAQ_MAX_COUNT:
                 break
-    if len(entries) < 5:
+    if len(entries) < FAQ_DEFAULT_LIMIT:
         for candidate in _generate_generic_entries(topic, list(keywords)):
-            if len(entries) == 5:
+            if len(entries) >= FAQ_DEFAULT_LIMIT:
                 break
             if candidate.question.lower() in seen_questions:
                 continue
             seen_questions.add(candidate.question.lower())
             entries.append(candidate)
 
-    if len(entries) != 5:
-        raise ValueError("Не удалось собрать пять валидных вопросов для FAQ")
+    if len(entries) < FAQ_MIN_COUNT:
+        raise ValueError("Не удалось собрать минимум шесть валидных вопросов для FAQ")
+    if len(entries) > FAQ_MAX_COUNT:
+        entries = entries[:FAQ_MAX_COUNT]
 
     rendered = _render_markdown(entries)
     placeholder = "<!--FAQ_START-->"
     end_placeholder = "<!--FAQ_END-->"
     if placeholder not in base_text or end_placeholder not in base_text:
         raise ValueError("FAQ placeholder missing in base text")
 
     before, remainder = base_text.split(placeholder, 1)
     inside, after = remainder.split(end_placeholder, 1)
     inside = inside.strip()
     if inside:
         rendered = f"{inside}\n\n{rendered}".strip()
     merged = f"{before}{placeholder}\n{rendered}\n{end_placeholder}{after}"
     jsonld = _build_jsonld(entries)
     # JSON-LD валидация
     try:
         raw_json = jsonld.split("\n", 1)[1].rsplit("\n", 1)[0]
         payload = json.loads(raw_json)
     except Exception as exc:  # noqa: BLE001
         raise ValueError(f"Некорректный JSON-LD FAQ: {exc}") from exc
-    if not isinstance(payload, dict) or payload.get("@type") != "FAQPage" or len(payload.get("mainEntity", [])) != 5:
+    main_entities = payload.get("mainEntity") if isinstance(payload, dict) else []
+    count = len(main_entities) if isinstance(main_entities, list) else 0
+    if (
+        not isinstance(payload, dict)
+        or payload.get("@type") != "FAQPage"
+        or count < FAQ_MIN_COUNT
+        or count > FAQ_MAX_COUNT
+    ):
         raise ValueError("JSON-LD FAQ не соответствует схеме FAQPage")
     return FaqBuildResult(text=merged, entries=entries, jsonld=jsonld)

