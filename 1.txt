diff --git a/frontend_demo/script.js b/frontend_demo/script.js
index ba7487ce8c7a152a82b1c4b9ed9857c3c0088e3b..d28184ab70b0d9daca9fe90250dd206105724303 100644
--- a/frontend_demo/script.js
+++ b/frontend_demo/script.js
@@ -1993,127 +1993,143 @@ async function handleReindex(event) {
       appendLogEntry("info", details.join(", "));
     }
     showToast({ message: "Ð˜Ð½Ð´ÐµÐºÑ Ð¾Ð±Ð½Ð¾Ð²Ð»Ñ‘Ð½", type: "success" });
     await handleHealthCheck();
   } catch (error) {
     console.error(error);
     appendLogEntry("error", getErrorMessage(error));
     showToast({ message: `ÐŸÐµÑ€ÐµÐ¸Ð½Ð´ÐµÐºÑÐ°Ñ†Ð¸Ñ: ${getErrorMessage(error)}`, type: "error" });
   } finally {
     setButtonLoading(reindexBtn, false);
     setInteractiveBusy(false);
   }
 }
 
 async function handleHealthCheck(event) {
   const triggeredByUser = event instanceof Event;
   if (triggeredByUser) {
     event.preventDefault();
     setInteractiveBusy(true);
     setButtonLoading(healthBtn, true);
   }
   try {
     const theme = pipeSelect.value;
     const query = theme ? `?theme=${encodeURIComponent(theme)}` : "";
     const response = await fetch(`${API_BASE}/api/health${query}`);
-    const text = await response.text();
+    let text = "";
+    try {
+      text = await response.text();
+    } catch (readError) {
+      renderHealthError("ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð·Ð°Ð¿Ñ€Ð¾ÑÐµ Health", "error");
+      return;
+    }
 
-    if (!response.ok) {
-      let message = text || `HTTP ${response.status}`;
+    let data = null;
+    if (text) {
       try {
-        const data = JSON.parse(text);
-        message = data.error || message;
+        data = JSON.parse(text);
       } catch (parseError) {
-        // keep original message
+        renderHealthError("ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ñ€Ð°Ð·Ð±Ð¾Ñ€Ðµ Health", "error");
+        return;
       }
-      throw new Error(message);
     }
 
-    let data;
-    try {
-      data = text ? JSON.parse(text) : null;
-    } catch (parseError) {
-      renderHealthError("ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð·Ð°Ð¿Ñ€Ð¾ÑÐµ Health", "error");
+    if (data && typeof data === "object" && data.checks) {
+      renderHealthStatus(data);
       return;
     }
 
-    renderHealthStatus(data);
+    const errorMessage =
+      (data && typeof data === "object" && (data.error || data.message)) ||
+      text ||
+      `HTTP ${response.status}`;
+    throw new Error(errorMessage);
   } catch (error) {
     console.error(error);
     if (error instanceof TypeError) {
       renderHealthError("Ð¡ÐµÑ€Ð²ÐµÑ€ Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½", "offline");
       return;
     }
     renderHealthError(error.message || "ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð·Ð°Ð¿Ñ€Ð¾ÑÐµ Health", "error");
   } finally {
     if (triggeredByUser) {
       setButtonLoading(healthBtn, false);
       setInteractiveBusy(false);
     }
   }
 }
 
 function renderHealthStatus(status) {
   healthStatus.innerHTML = "";
   const checks = status?.checks;
   if (!checks || typeof checks !== "object" || !Object.keys(checks).length) {
     renderHealthError("ÐÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ…", "error");
     return;
   }
 
-  Object.entries(checks).forEach(([key, value], index) => {
+  const entries = Object.entries(checks);
+
+  entries.forEach(([key, value], index) => {
     const normalized = normalizeHealthCheck(value);
     const tone = normalized.ok ? "success" : "error";
     const icon = normalized.ok ? "ðŸŸ¢" : "ðŸ”´";
     const dictionary = HEALTH_STATUS_MESSAGES[key] || {};
     const label = dictionary.label || key.replace(/_/g, " ");
     const description =
       normalized.message || (normalized.ok ? dictionary.ok : dictionary.fail) || (normalized.ok ? "Ð°ÐºÑ‚Ð¸Ð²ÐµÐ½" : "Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½");
 
     const card = createHealthCard({
       tone,
       icon,
       label,
       description,
       delay: index * 80,
     });
     card.dataset.healthKey = key;
     healthStatus.append(card);
   });
-  const failingEntry = Object.entries(checks).find(([, value]) => !normalizeHealthCheck(value).ok);
-  const fallbackDictionary = failingEntry ? HEALTH_STATUS_MESSAGES[failingEntry[0]] || {} : {};
-  const reason = failingEntry
-    ? normalizeHealthCheck(failingEntry[1]).message || fallbackDictionary.fail || "ÐœÐ¾Ð´ÐµÐ»ÑŒ Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð°"
-    : "";
-  setGenerateAvailability(Boolean(status?.ok), reason);
+  const bad = entries.some(([, value]) => value && value.ok === false);
+  const overallOk = status?.ok === true && !bad;
+  const failingEntry = entries.find(([, value]) => value && value.ok === false);
+  let failingMessage = "";
+  if (failingEntry) {
+    const [, rawValue] = failingEntry;
+    if (rawValue && typeof rawValue === "object" && typeof rawValue.message === "string") {
+      failingMessage = rawValue.message;
+    } else {
+      const dictionary = HEALTH_STATUS_MESSAGES[failingEntry[0]] || {};
+      failingMessage = dictionary.fail || "ÐœÐ¾Ð´ÐµÐ»ÑŒ Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð°";
+    }
+  }
+  setGenerateAvailability(overallOk, failingMessage);
 }
 
 function normalizeHealthCheck(value) {
   if (value && typeof value === "object") {
     return {
-      ok: Boolean(value.ok),
-      message: value.message || value.status || "",
+      ok: value.ok === true,
+      message: (typeof value.message === "string" && value.message) || value.status || "",
     };
   }
   return {
     ok: Boolean(value),
     message: "",
   };
 }
 
 function renderHealthError(message, tone = "error") {
   healthStatus.innerHTML = "";
   const icon = tone === "success" ? "ðŸŸ¢" : tone === "offline" ? "âšª" : "ðŸ”´";
   const card = createHealthCard({
     tone,
     icon,
     label: message,
     description: tone === "offline" ? "ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¾Ð±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð¿Ð¾Ð·Ð¶Ðµ" : "",
   });
   healthStatus.append(card);
   setGenerateAvailability(false, message);
 }
 
 function createHealthCard({ tone, icon, label, description = "", delay = 0 }) {
   const card = document.createElement("div");
   card.className = `health-card ${tone}`;
   card.style.animationDelay = `${delay}ms`;
@@ -2130,50 +2146,52 @@ function createHealthCard({ tone, icon, label, description = "", delay = 0 }) {
   labelEl.textContent = label;
   contentEl.append(labelEl);
 
   if (description) {
     const descriptionEl = document.createElement("div");
     descriptionEl.className = "health-description";
     descriptionEl.textContent = description;
     contentEl.append(descriptionEl);
   }
 
   card.append(iconEl, contentEl);
   return card;
 }
 
 function setGenerateAvailability(ok, reason = "") {
   if (!generateBtn) {
     return;
   }
   if (ok) {
     generateBtn.disabled = false;
     generateBtn.removeAttribute("title");
   } else {
     generateBtn.disabled = true;
     if (reason) {
       generateBtn.title = reason;
+    } else {
+      generateBtn.removeAttribute("title");
     }
   }
 }
 
 async function fetchJson(path, options = {}) {
   const headers = options.headers ? { ...options.headers } : {};
   if (options.method && options.method !== "GET") {
     headers["Content-Type"] = "application/json";
   }
 
   let response;
   try {
     response = await fetch(`${API_BASE}${path}`, { ...options, headers });
   } catch (error) {
     throw new Error("Ð¡ÐµÑ€Ð²ÐµÑ€ Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½");
   }
 
   let text;
   try {
     text = await response.text();
   } catch (error) {
     throw new Error("ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ñ‚ÑŒ Ð¾Ñ‚Ð²ÐµÑ‚ ÑÐµÑ€Ð²ÐµÑ€Ð°");
   }
 
   if (!response.ok) {
diff --git a/orchestrate.py b/orchestrate.py
index 81a33fdcc602f453f87ed335e4a509a8a909fac9..50a77990c895d49594100b73e00706f403b65115 100644
--- a/orchestrate.py
+++ b/orchestrate.py
@@ -514,122 +514,188 @@ def generate_article_from_payload(
         timeout=resolved_timeout,
         mode=mode or "final",
         output_path=output_path,
         backoff_schedule=backoff_schedule,
         append_style_profile=append_style_profile,
         context_source=context_source,
         context_text=context_text,
         context_filename=context_filename,
     )
     artifact_files = result.get("artifact_files")
     artifact_paths = None
     if artifact_files:
         artifact_paths = {
             "markdown": artifact_files["markdown"].as_posix(),
             "metadata": artifact_files["metadata"].as_posix(),
         }
     return {
         "text": result["text"],
         "metadata": result["metadata"],
         "artifact_paths": artifact_paths,
     }
 
 
 def gather_health_status(theme: Optional[str]) -> Dict[str, Any]:
     checks: Dict[str, Dict[str, object]] = {}
-    ok = True
 
-    api_key = (os.getenv("OPENAI_API_KEY") or OPENAI_API_KEY).strip()
-    if not api_key:
-        checks["openai_key"] = {"ok": False, "message": "OPENAI_API_KEY Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½"}
-        ok = False
-    else:
-        masked = f"{api_key[:4]}***{api_key[-4:]}" if len(api_key) > 8 else "*" * len(api_key)
-        checks["openai_key"] = {"ok": True, "message": f"ÐšÐ»ÑŽÑ‡ Ð½Ð°Ð¹Ð´ÐµÐ½ ({masked})"}
-
-        try:
-            probe_messages = [
-                {"role": "system", "content": "Ð¢Ñ‹ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð³Ð¾Ñ‚Ð¾Ð²Ð½Ð¾ÑÑ‚Ð¸. ÐžÑ‚Ð²ÐµÑ‚ÑŒ ÑÑ‚Ñ€Ð¾Ð³Ð¾ ÑÐ»Ð¾Ð²Ð¾Ð¼ PING."},
-                {"role": "user", "content": "ÐžÑ‚Ð²ÐµÑ‚ÑŒ ÑÐ»Ð¾Ð²Ð¾Ð¼ PING"},
-            ]
-            ping_result = llm_generate(
-                probe_messages,
-                model=DEFAULT_MODEL,
-                temperature=0.0,
-                max_tokens=32,
-                timeout_s=10,
-            )
-            reply = (ping_result.text or "").strip().lower()
-            route = (ping_result.api_route or "").strip().lower()
-            used_fallback = bool(ping_result.fallback_used)
-            ping_ok = reply.startswith("ping") and route == "responses" and not used_fallback
-            if ping_ok:
-                checks["openai_key"]["message"] = f"ÐšÐ»ÑŽÑ‡ Ð°ÐºÑ‚Ð¸Ð²ÐµÐ½ ({masked})"
-                checks["llm_ping"] = {"ok": True, "message": "ÐžÑ‚Ð²ÐµÑ‚ PING Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½"}
-            else:
-                ok = False
-                message = "OpenAI API Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½"
-                if reply and not reply.startswith("ping"):
-                    message = f"OpenAI API Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½ (Ð¾Ñ‚Ð²ÐµÑ‚: {ping_result.text[:32]})"
-                elif route != "responses" or used_fallback:
-                    message = "OpenAI API Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½ (fallback)"
-                checks["llm_ping"] = {"ok": False, "message": message}
-        except Exception:  # noqa: BLE001
-            ok = False
-            checks["llm_ping"] = {"ok": False, "message": "OpenAI API Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½"}
-
-    artifacts_dir = Path("artifacts")
+    artifacts_dir = Path("artifacts").resolve()
     try:
         artifacts_dir.mkdir(parents=True, exist_ok=True)
         probe = artifacts_dir / ".write_check"
         probe.write_text("ok", encoding="utf-8")
         probe.unlink()
-        checks["artifacts_writable"] = {"ok": True, "message": "Ð—Ð°Ð¿Ð¸ÑÑŒ Ð² artifacts/ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð°"}
+        checks["artifacts_writable"] = {
+            "ok": True,
+            "message": f"ÐÑ€Ñ‚ÐµÑ„Ð°ÐºÑ‚Ñ‹ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹: {artifacts_dir}",
+        }
     except Exception as exc:  # noqa: BLE001
-        ok = False
-        checks["artifacts_writable"] = {"ok": False, "message": f"ÐÐµÑ‚ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð° Ðº artifacts/: {exc}"}
+        checks["artifacts_writable"] = {
+            "ok": False,
+            "message": f"ÐÑ€Ñ‚ÐµÑ„Ð°ÐºÑ‚Ñ‹ Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹: {exc}",
+        }
+
+    api_key = (os.getenv("OPENAI_API_KEY") or OPENAI_API_KEY).strip()
+    masked_key = _mask_openai_key(api_key)
+    if api_key:
+        checks["openai_key"] = {
+            "ok": True,
+            "message": f"ÐšÐ»ÑŽÑ‡ Ð½Ð°Ð¹Ð´ÐµÐ½ ({masked_key})",
+        }
+        checks["llm_ping"] = _run_health_ping()
+    else:
+        checks["openai_key"] = {
+            "ok": False,
+            "message": "OPENAI_API_KEY Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½",
+        }
+        checks["llm_ping"] = {
+            "ok": False,
+            "message": "Responses Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½: ÐºÐ»ÑŽÑ‡ Ð½Ðµ Ð·Ð°Ð´Ð°Ð½",
+            "route": "responses",
+            "fallback_used": False,
+        }
 
     theme_slug = (theme or "").strip()
     if not theme_slug:
-        checks["theme_index"] = {"ok": False, "message": "Ð¢ÐµÐ¼Ð° Ð½Ðµ ÑƒÐºÐ°Ð·Ð°Ð½Ð°"}
-        ok = False
+        checks["theme_index"] = {
+            "ok": False,
+            "message": "Ð¢ÐµÐ¼Ð° Ð½Ðµ ÑƒÐºÐ°Ð·Ð°Ð½Ð°",
+        }
     else:
         index_path = Path("profiles") / theme_slug / "index.json"
         if not index_path.exists():
-            checks["theme_index"] = {"ok": False, "message": f"Ð˜Ð½Ð´ÐµÐºÑ Ð´Ð»Ñ Ñ‚ÐµÐ¼Ñ‹ '{theme_slug}' Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½"}
-            ok = False
+            checks["theme_index"] = {
+                "ok": False,
+                "message": f"Ð˜Ð½Ð´ÐµÐºÑ Ð´Ð»Ñ Ñ‚ÐµÐ¼Ñ‹ '{theme_slug}' Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½",
+            }
         else:
             try:
                 json.loads(index_path.read_text(encoding="utf-8"))
-                checks["theme_index"] = {"ok": True, "message": f"Ð˜Ð½Ð´ÐµÐºÑ Ð½Ð°Ð¹Ð´ÐµÐ½ ({index_path})"}
+                checks["theme_index"] = {
+                    "ok": True,
+                    "message": f"ÐŸÑ€Ð¾Ñ„Ð¸Ð»ÑŒ Ñ‚ÐµÐ¼Ñ‹ Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½ ({index_path.as_posix()})",
+                }
             except json.JSONDecodeError as exc:
-                ok = False
-                checks["theme_index"] = {"ok": False, "message": f"Ð˜Ð½Ð´ÐµÐºÑ Ð¿Ð¾Ð²Ñ€ÐµÐ¶Ð´Ñ‘Ð½: {exc}"}
+                checks["theme_index"] = {
+                    "ok": False,
+                    "message": f"Ð˜Ð½Ð´ÐµÐºÑ Ð¿Ð¾Ð²Ñ€ÐµÐ¶Ð´Ñ‘Ð½: {exc}",
+                }
 
+    ok = all(check.get("ok") is True for check in checks.values())
     return {"ok": ok, "checks": checks}
 
 
+def _mask_openai_key(raw_key: str) -> str:
+    key = (raw_key or "").strip()
+    if not key:
+        return "****"
+    if key.startswith("sk-") and len(key) > 6:
+        return f"sk-****{key[-4:]}"
+    if len(key) <= 4:
+        return "*" * len(key)
+    return f"{key[:2]}***{key[-2:]}"
+
+
+def _run_health_ping() -> Dict[str, object]:
+    probe_messages = [
+        {
+            "role": "system",
+            "content": "Ð¢Ñ‹ ÑÐµÑ€Ð²Ð¸Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ÑÑ‚Ð¸. ÐžÑ‚Ð²ÐµÑ‚ÑŒ ÑÐ»Ð¾Ð²Ð¾Ð¼ PONG.",
+        },
+        {"role": "user", "content": "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¾Ñ‚Ð²ÐµÑ‚ÑŒ ÑÑ‚Ñ€Ð¾Ð³Ð¾ ÑÐ»Ð¾Ð²Ð¾Ð¼ PONG."},
+    ]
+
+    try:
+        ping_result = llm_generate(
+            probe_messages,
+            model=DEFAULT_MODEL,
+            temperature=0.0,
+            max_tokens=32,
+            timeout_s=10,
+        )
+    except Exception as exc:  # noqa: BLE001
+        reason = str(exc).strip() or "Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð²Ñ‹Ð·Ð¾Ð²Ð°"
+        return {
+            "ok": False,
+            "message": f"Responses Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½: {reason}",
+            "route": "responses",
+            "fallback_used": False,
+        }
+
+    reply = (ping_result.text or "").strip()
+    reply_lower = reply.lower()
+    route = (ping_result.api_route or "").strip() or "responses"
+    fallback_used = bool(ping_result.fallback_used)
+
+    if reply_lower.startswith("pong") and route == "responses" and not fallback_used:
+        model_used = (ping_result.model_used or DEFAULT_MODEL).strip() or DEFAULT_MODEL
+        return {
+            "ok": True,
+            "message": f"Responses OK ({model_used}, 32 Ñ‚Ð¾ÐºÐµÐ½Ð°)",
+            "route": "responses",
+            "fallback_used": False,
+        }
+
+    if fallback_used:
+        reason = f"Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½ fallback {ping_result.fallback_used}"
+    elif route != "responses":
+        reason = f"Ð¼Ð°Ñ€ÑˆÑ€ÑƒÑ‚ {route}"
+    elif reply:
+        truncated = reply.replace("\n", " ")
+        if len(truncated) > 60:
+            truncated = f"{truncated[:57]}..."
+        reason = f"Ð¾Ñ‚Ð²ÐµÑ‚: {truncated}"
+    else:
+        reason = "Ð¿ÑƒÑÑ‚Ð¾Ð¹ Ð¾Ñ‚Ð²ÐµÑ‚"
+
+    return {
+        "ok": False,
+        "message": f"Responses Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½: {reason}",
+        "route": route or "responses",
+        "fallback_used": fallback_used,
+    }
+
+
 def _parse_args() -> argparse.Namespace:
     parser = argparse.ArgumentParser(description="Deterministic content pipeline")
     parser.add_argument("--theme", required=True, help="Theme slug (profiles/<theme>)")
     parser.add_argument("--data", required=True, help="Path to JSON brief")
     parser.add_argument("--outfile", help="Override output path")
     parser.add_argument("--k", type=int, default=0, help="Number of exemplar clips")
     parser.add_argument("--model", help="Optional model label for metadata")
     parser.add_argument("--temperature", type=float, default=0.0)
     parser.add_argument("--max-tokens", type=int, default=0, dest="max_tokens")
     parser.add_argument("--timeout", type=int, default=60)
     parser.add_argument("--mode", default="final")
     parser.add_argument("--retry-backoff", help="Retry schedule (unused)")
     parser.add_argument("--append-style-profile", action="store_true")
     parser.add_argument("--context-source")
     parser.add_argument("--context-text")
     parser.add_argument("--context-filename")
     parser.add_argument("--check", action="store_true")
     return parser.parse_args()
 
 
 def _load_input(path: str) -> Dict[str, Any]:
     payload_path = Path(path)
     if not payload_path.exists():
         raise FileNotFoundError(f"ÐÐµ Ð½Ð°Ð¹Ð´ÐµÐ½ Ñ„Ð°Ð¹Ð» Ð²Ñ…Ð¾Ð´Ð½Ñ‹Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ…: {payload_path}")
     try:
diff --git a/server/__init__.py b/server/__init__.py
index 510f86352471c89fcfbdc5b9fcb3d3f0cd720821..6b0e8689462d82b38ffaaa55e7982a52e221e3b8 100644
--- a/server/__init__.py
+++ b/server/__init__.py
@@ -78,50 +78,52 @@ def login_required(view_func):
             next_url = request.full_path if request.query_string else request.path
             if next_url.endswith("?"):
                 next_url = next_url[:-1]
             safe_next = _get_safe_redirect_target(next_url)
             if safe_next:
                 return redirect(url_for("login", next=safe_next))
             return redirect(url_for("login"))
         return view_func(*args, **kwargs)
 
     return wrapper
 
 
 class ApiError(Exception):
     """Exception translated into an HTTP error response."""
 
     def __init__(self, message: str, status_code: int = 400) -> None:
         super().__init__(message)
         self.status_code = status_code
         self.message = message
 
 
 def create_app() -> Flask:
     frontend_root = (Path(__file__).resolve().parent.parent / "frontend_demo").resolve()
     template_root = frontend_root / "templates"
     app = Flask(__name__, template_folder=str(template_root))
+    if hasattr(app, "json"):
+        app.json.ensure_ascii = False
     CORS(app, resources={r"/api/*": {"origins": "*"}})
 
     secret_key = os.environ.get("FLASK_SECRET_KEY")
     if not secret_key:
         LOGGER.warning("FLASK_SECRET_KEY is not set; generating a temporary secret key")
     app.secret_key = secret_key or secrets.token_hex(32)
 
     index_path = frontend_root / "index.html"
 
     @app.context_processor
     def inject_current_user():
         username = session.get("user")
         return {
             "current_user": USERS.get(username),
             "current_username": username,
         }
 
     @app.errorhandler(ApiError)
     def _handle_api_error(exc: ApiError):  # type: ignore[override]
         LOGGER.warning("API error: %s", exc.message)
         return jsonify({"error": exc.message}), exc.status_code
 
     @app.errorhandler(Exception)
     def _handle_generic_error(exc: Exception):  # type: ignore[override]
         LOGGER.exception("Unhandled error")
diff --git a/tests/test_orchestrate_utils.py b/tests/test_orchestrate_utils.py
index 2d4c961763f8789837ecef390c41e60191ecc73c..6e2b2daaa47bc0db96be1504ce98446831319cbb 100644
--- a/tests/test_orchestrate_utils.py
+++ b/tests/test_orchestrate_utils.py
@@ -297,25 +297,29 @@ def test_generate_article_returns_metadata(monkeypatch, tmp_path):
         "keywords": [f"ÐºÐ»ÑŽÑ‡ {idx}" for idx in range(1, 12)],
         "include_jsonld": True,
         "context_source": "off",
     }
     result = generate_article_from_payload(
         theme="finance",
         data=data,
         k=0,
         context_source="off",
         outfile=str(outfile),
     )
     metadata = result["metadata"]
     assert metadata["validation"]["passed"]
     assert Path(outfile).exists()
     assert metadata["pipeline_logs"]
     # cleanup
     Path(outfile).unlink(missing_ok=True)
     Path(outfile.with_suffix(".json")).unlink(missing_ok=True)
 
 
 def test_gather_health_status_handles_missing_theme(monkeypatch):
     monkeypatch.setenv("OPENAI_API_KEY", "")
     status = gather_health_status(theme="")
     assert not status["ok"]
     assert not status["checks"]["theme_index"]["ok"]
+    llm_ping = status["checks"]["llm_ping"]
+    assert llm_ping["route"] == "responses"
+    assert llm_ping["fallback_used"] is False
+    assert not llm_ping["ok"]

